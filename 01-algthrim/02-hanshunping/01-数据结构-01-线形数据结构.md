[toc]

<extoc></extoc>



## 数据结构

> 数据结构是算法的基础
>
> 数据结构分为线性结构和非线性结构



### 1, 线性结构

* 线性结构作为最常用的数据结构，其特点是数据元素之间存在==一对一==的线性关系
* 线性结构常见的有：==数组==、==队列==、==链表==和==栈==，
* 线性结构有两种不同的存储结构，即==**顺序存储结构(包括数组队列栈)**==和==**链式存储结构(包括)**==。
* 顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的
* 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息



#### 1.1, 数组

##### 稀疏数组(sparseArray)

> 稀疏数组其实是一个二维数组，这里放在线性结构的数组里面并不合适。所以放入非线性结构的二维数组中记录



#### 1.2, 队列

> 队列是一个有序列表， 可以用数组(顺序存储)或链表(链式存储)实现，
>
> 队列的原则： FIFO先进先出

##### 单向队列

数组模拟简单队列

下图默认索引从-1开始， 我们代码中使用0开始

![image-20210424145640938](https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210424145640938.png)



* 数组模拟的队列会有队列容量限制，一旦超过指定数量就不能进行数据的添加。而且全部出列后不能进行队列的重用。
* 初始值：front = 0;rear = 0;

* 队列满条件：rear == maxSize
* 队列空条件：rear == front
* 添加数据rear后移：rear++;
* 获取数据，头部后移：front++;

```java
package im.bool.a02_queue;

import java.util.Scanner;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/8 11:41 AM
 * #Desc   : 这个把rear默认等于0， front也默认等于0，相当于环形队列初始值再重新做一下，好和环形队列逻辑基本一致
 **/
public class a02_queueByArray01 {

    public static void main(String[] args) {

        ArrayQueue01 queue = new ArrayQueue01(3);
        char key;
        Scanner scanner = new Scanner(System.in);
        boolean loop = true;
        while(loop) {
            System.out.println("s(show): 显示队列");
            System.out.println("e(exit): 退出");
            System.out.println("a(add): 添加队列");
            System.out.println("g(get): 获取");
            System.out.println("h(head): 显示头部数据");
            System.out.println("i(info): 显示头部数据");
            key = scanner.next().charAt(0);
            switch (key) {
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输入数据：");
                    int value = scanner.nextInt();
                    queue.addToQueue(value);
                    break;
                case 'g':
                    try {
                        int res = queue.getDataFromQueue();
                        System.out.println("数据是：\n" + res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':
                    try {
                        int res = queue.showHeadData();
                        System.out.printf("头部数据是：%d\n", res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'i':
                    try {
                        queue.showInfo();
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出");
    }

}


class ArrayQueue01 {

    //队列最大容量
    private final int maxSize;
    //队列第一个位置
    private int front;
    //队列最后一个元素位置
    private int rear;

    //存放数据的地方，模拟队列
    private final int[] arr;

    //这个是构造方法
    public ArrayQueue01(int maxSize) {
        this.maxSize = maxSize;
        arr = new int[maxSize];
        //这里都定义成0，代表执行队列头部
        front = 0;
        rear = 0;
    }

    public void addToQueue(int n) {
        if (isFull()) {
            System.out.println("队列已满，不能添加数据");
            return;
        }
        //先赋值然后再后移
        arr[rear] = n;
        rear++;
    }

    //判断队列是否满了
    public boolean isFull() {
        return rear == maxSize;
    }

    public boolean isEmpty() {
        return rear == front;
    }

    public int getDataFromQueue() {
        if (isEmpty()) {
            System.out.println("队列为空，不可取数据");
            throw new RuntimeException("队列为空异常");
        }
        int data = arr[front];
        front++;
        return data;
    }

    //显示队列的所有数据
    public void showQueue() {
        if (isEmpty()) {
            System.out.println("队列为空，直接返回");
            return;
        }

        for (int i = front; i < arr.length; i++) {
            System.out.println("arr[" + i + "]=" + arr[i]);
        }
    }

    //显示队列的头部数据，这里只显示，不取
    public Integer showHeadData() {
        if (isEmpty()) {
            System.out.println("队列为空，直接返回");
            return null;
        }
        return arr[front + 1];
    }


    public void showInfo() {
        System.out.println("front=" + front);
        System.out.println("rear=" + rear);
    }
}

```

##### 环形队列

数组模拟环形队列,需要用到一些算法

* 初始值：front = 0;rear = 0;
* 队列满条件：(rear+1)%maxSize == front， 因为是环形队列， 能循环使用，所以不能直接rear=front，因为默认空的时候也满足这个条件。所以只能空一个数据出来，这样只有数据满的时候才会满足(rear+1)%maxSize == front
* 队列空条件：rear == front
* 添加数据rear后移：rear = (rear+1)%maxSize;
* 获取数据，头部后移：front = (front+1)%maxSize;
* 环形队列有一个限制：队列大小不能为1，因为算法中在数组中预留了一个位置，如果队列大小是1，那么队列永远是满的

```java
package im.bool.a02_queue;

import java.util.Scanner;

/**
 * #Author : ivanl001
 * #Date   : 2019/11/9 14:46
 * #Desc   : 数组模拟成环形队列
 * 思路分析：之前的数组模拟简单队列：front表示头部，指向队列的队列的前一个位置， rear表示尾部。
 *         模拟环形队列需要把front改变一下， front执行队列的第一个元素
 *         rear也要改变一下，rear指向队列最后一个元素。因为希望空出一个空间作为约定。
 *         那么当队列满时候，则：rear+1-front = maxSize
 **/
public class a03_circleQueueByArray {

    public static void main(String[] args) {

        CircleArray queue = new CircleArray(1);
        char key = ' ';
        Scanner scanner = new Scanner(System.in);//
        boolean loop = true;
        while(loop) {
            System.out.println("s(show): 显示队列");
            System.out.println("e(exit): 退出");
            System.out.println("a(add): 添加队列");
            System.out.println("g(get): 获取");
            System.out.println("h(head): 显示头部数据");
            System.out.println("i(info): 显示头部数据");

            key = scanner.next().charAt(0);
            switch (key) {
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输入数据：");
                    int value = scanner.nextInt();
                    queue.addToQueue(value);
                    break;
                case 'g':
                    try {
                        int res = queue.getDataFromQueue();
                        System.out.println("数据是：\n" + res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':
                    try {
                        int res = queue.showHeadData();
                        System.out.printf("头部数据是：%d\n", res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'i':
                    try {
                        queue.showInfo();
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出");
    }

}


class CircleArray {

    private final int maxSize;
    //front初始值为0
    private int front;
    //rear初始值为0
    private int rear;
    private final int[] arr;

    public CircleArray(int arrMaxSize) {
        /*if (arrMaxSize < 2) {
            throw new RuntimeException("队列只有一个内容，不必要做队列");
        }*/
        // 环形队列有一个限制：队列大小不能为1
        // 因为环形队列的rear = (rear+1)%maxSize;
        // 如果为1的话，(rear+1)%maxSize==front用来判断队列，永远是满的

        maxSize = arrMaxSize;
        arr = new int[maxSize];
        //下一个位置，也就是元素的后面一个位置
        front = 0;
        rear = 0;
    }

    //添加数据到队列
    public void addToQueue(int n) {
        //判断是否满,这个是移动前判断，所以不论何时，队列中至少会有一个位置会空出来。
        if (isFull()) {
            System.out.println("队列已满，不能添加到队列");
            return;
        }
        arr[rear] = n;
        //rear++;
        // rear后移一位,判断是否满其实就是判断后移这一位之后会不会等于front，等于说明满了。
        rear = (rear+1)%maxSize;
    }

    //判读是否队列已满
    public boolean isFull() {
        // 这个地方因为是先加1判断的， 所以数组中至少会预留一个位置，不会全部占用
        return (rear+1)%maxSize==front;
    }

    public int getDataFromQueue() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空，不能取数据");
        }

        int value = arr[front];
        front = (front+1)%maxSize;
        return value;
    }

    //判断队列是否为空
    public boolean isEmpty() {
        return rear == front;
    }

    //显示队列方法
    public void showQueue(){
        //
        if (isEmpty()) {
            System.out.println("队列为空， 没有数据～～");
            return;
        }
        //环形队列不一定是从0开始有数据，所以需要从front遍历， 遍历数据个数是(rear-front)%maxSize
        // front + (rear+maxSize-front)%maxSize: 这个可以理解：上午九点和上午11点差两个小时，上午9点和下午一点差距：下午1点+12 - 9 = 4
        for (int i = front; i < front + (rear+maxSize-front)%maxSize; i++) {
            System.out.printf("arr[%d]=%d\n", i%maxSize, arr[i%maxSize]);
        }
    }

    public int showHeadData() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空， 无数据");
        }
        return arr[front];
    }

    public void showInfo() {
        System.out.println("front=" + front);
        System.out.println("rear=" + rear);
    }
}

```



#### 1.3, 链表

> 链表是以节点的方式来存储,是链式存储
> 每个节点包含 data 域， next 域：指向下一个节点.
> 如图：发现链表的各个节点不一定是连续存储.
> 链表分为：==带头节点的链表==和==没有头节点的链表==，根据实际的需求来确定



##### 单向链表

* 单链表反转
  * 使用新的链表，把老链表下一个节点插入新链表头部， 最后把新链表赋值给老链表

```java
//面试题：单链表的反转
//思路：
// 1，链表只要有头节点head，通过head可以找到完整的链表
// 2, 先新建一个临时tempHead，把head的下一个节点node1，剪切放入到临时链表的头节点后面。
// 3, 然后head的下一个节点，也就是原先链表的第二个节点node2，成为了原先链表的第一个节点，重复2，也就是剪切放入到临时链表的头节点的后面，也就是tempHead和node1中间，然后就变成临时节点的倒数第二个节点了
// 4, 重复上面的步骤， 直到原链表head后面的节点全部在临时链表中排序好
// 5, 最后把临时链表中的数据，赋值给head即可
public void reverse() {

    // 链表为空或者链表只有一个除head之外的节点，则不需要反转
    if (head.next == null || head.next.next == null) {
        System.out.println("无数据库或者数据仅有1个，无需反转即使正确的");
        return;
    }

    // 定义一些辅助变量指针，帮我们遍历原来的链表
    HeroNode current = head.next;
    HeroNode next;

    // 这个头是先用来把数据排好序，最后再把排好序的数据部分赋值给head
    HeroNode tempHead = new HeroNode(0, "", "");

    while (current != null) {

        // 先暂时保存current节点的下一个节点，要不到时候就找不到进入口了。因为current到时候会给temp，到时候current的next就会变掉了
        next = current.next;

        // 把current夹在新的排序的链表head节点紧着后面，依次下来之后就相当于反转了。
        current.next = tempHead.next;
        tempHead.next = current;

        //再把原先的链表删除掉已经添加到新的链表中的那个节点
        current = next;
    }

    //最后把排序的链表重新赋值给原链表即可
    head.next = tempHead.next;
    //到这里原链表就被拷贝到新的链表上排好序，又给赋值回来了

```

* 单链表逆序打印(不改变元链表)
  * ==放入栈中==

```java
// 面试题：逆序打印单链表的节点
// 先遍历，取出来后放入栈中，然后逐步pop出来即可
public void printDesc() {
    if (head.next == null) {
        System.out.println("空链表");
        return;
    }
    Stack<HeroNode> heroNodes = new Stack<HeroNode>();
    HeroNode temp = head.next;
    while (temp != null) {
        heroNodes.push(temp);
        temp = temp.next;
    }

    while (heroNodes.size() > 0) {
        System.out.println(heroNodes.pop());
    }
}
```

* 
  * ==使用迭代==

```java
//注意：这里是个静态方法，只需要传入链表的第一个节点即可
public static void printDesc_v1(HeroNode node) {
    if (node != null) {
        printDesc_v1(node.next);
    }
    if (node != null) {
        System.out.println(node);
    }
}
```



*  链表的真正代码

* 如下代码中链表包含一个头节点，改节点作为定位节点，不存储任何数据信息

* 如下代码包含链表的创建， 新增，更改，删除等等

```java
package im.bool.a03_linked_list;

import java.util.Stack;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/8 5:43 PM
 * #Desc   : 一个简单的单向链表的实现
 **/
public class a03_01_singleLinkedList {

    public static void main(String[] args) {

        //这个是按照添加顺序进行排序
        HeroNode heroNode01 = new HeroNode(1, "宋江", "及时雨");
        HeroNode heroNode02 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode heroNode03 = new HeroNode(3, "吴用", "智多星");
        HeroNode heroNode04 = new HeroNode(4, "林冲", "豹子头");

        SingleLinkedList singleLinkedList = new SingleLinkedList();
        singleLinkedList.add(heroNode01);
        singleLinkedList.add(heroNode04);
        singleLinkedList.add(heroNode02);
        singleLinkedList.add(heroNode03);

        singleLinkedList.showLinkedList();

        /*singleLinkedList.reverse();
        System.out.println("逆序");
        singleLinkedList.showLinkedList();*/

        System.out.println("逆序打印，不会改变原始结构");
        singleLinkedList.printDesc();


        //这个是按照英雄编号进行排序，跟添加顺序无关
        /*HeroNode heroNode01 = new HeroNode(1, "宋江", "及时雨");
        HeroNode heroNode02 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode heroNode03 = new HeroNode(3, "吴用", "智多星");
        HeroNode heroNode04 = new HeroNode(4, "林冲", "豹子头");

        SingleLinkedList singleLinkedList = new SingleLinkedList();

        System.out.println(singleLinkedList.getSize());

        singleLinkedList.addByOrder(heroNode01);
        singleLinkedList.addByOrder(heroNode03);
        singleLinkedList.addByOrder(heroNode03);
        singleLinkedList.addByOrder(heroNode02);
        singleLinkedList.addByOrder(heroNode04);

        singleLinkedList.showLinkedList();*/



        /*System.out.println(singleLinkedList.getSize());

        System.out.println(singleLinkedList.getndNode(4));

        System.out.println("--------------");
        System.out.println(singleLinkedList.getLstndNode(3));*/



        /*heroNode01 = new HeroNode(3, "zhangdanfeng", "及时雨");
        singleLinkedList.updateHeroNode(heroNode01);
        singleLinkedList.showLinkedList();

        System.out.println("-------------------------");
        singleLinkedList.deleteHeroNodeByNo(3);
        singleLinkedList.showLinkedList();

        System.out.println("-------------------------");
        singleLinkedList.deleteHeroNodeByNo(2);
        singleLinkedList.showLinkedList();

        System.out.println("-------------------------");
        singleLinkedList.deleteHeroNodeByNo(1);
        singleLinkedList.deleteHeroNodeByNo(1);
        singleLinkedList.showLinkedList();


        System.out.println("-------------------------");
        singleLinkedList.deleteHeroNodeByNo(4);
        singleLinkedList.showLinkedList();


        System.out.println("-------------------------");
        singleLinkedList.deleteHeroNodeByNo(5);
        singleLinkedList.showLinkedList();*/

    }
  
  	// 迭代实现逆序打印
    public static void printDesc_v1(HeroNode node) {
        if (node != null) {
            printDesc_v1(node.next);
        }
        if (node != null) {
            System.out.println(node);
        }
    }
}

class SingleLinkedList {
    //先定义一个头节点，头节点什么都不存， 且不能改动
    private HeroNode head = new HeroNode(0, "", "");

    //面试题：逆序打印单链表的节点
    //先遍历，取出来后放入栈中，然后逐步pop出来即可
    public void printDesc() {
        if (head.next == null) {
            System.out.println("空链表");
            return;
        }
        Stack<HeroNode> heroNodes = new Stack<HeroNode>();

        HeroNode temp = head.next;
        while (temp != null) {
            heroNodes.push(temp);
            temp = temp.next;
        }

        while (heroNodes.size() > 0) {
            System.out.println(heroNodes.pop());
        }
    }


    //面试题：单链表的反转
    //思路：1，链表只要有头节点head，通过head可以找到完成的链表
    //2, 先新建一个临时tempHead，把head的下一个节点node1，剪切放入到临时链表的头节点后面。
    //3, 然后head的下一个节点，也就是原先链表的第二个节点node2，成为了原先链表的第一个节点，重复2，也就是剪切放入到临时链表的头节点的后面，也就是tempHead和node1中间，然后就变成临时节点的倒数第二个节点了
    //4, 重复上面的步骤， 直到原链表head后面的节点全部在临时链表中排序好
    //5, 最后把临时链表中的数据，赋值给head即可
    public void reverse() {

        if (head.next == null || head.next.next == null) {
            System.out.println("无数据库或者数据仅有1个，无需反转即使正确的");
            return;
        }

        //定义一些辅助变量指针，帮我们遍历原来的链表
        HeroNode current = head.next;
        HeroNode next;
        //这个头是先用来把数据排好序，最后再把排好序的数据部分赋值给head
        HeroNode tempHead = new HeroNode(0, "", "");

        while (current != null) {
            next = current.next;//先暂时保存current节点的下一个节点，要不到时候就找不到进入口了。因为current到时候会给temp，到时候current的next就会变掉了

            //把current夹在新的排序的链表head节点紧着后面，依次下来之后就相当于反转了。
            current.next = tempHead.next;
            tempHead.next = current;

            //再把原先的链表删除掉已经添加到新的链表中的那个节点
            current = next;
        }

        //最后把排序的链表重新赋值给原链表即可
        head.next = tempHead.next;
        //到这里原链表就被拷贝到新的链表上排好序，又给赋值回来了
    }




    //获取倒数第n个节点
    public HeroNode getLstndNode(int n) {
        if (n > getSize()) {
            System.out.println("该链表一共" + getSize() + "个元素");
            return null;
        }

        int theNo = getSize() - n + 1;
        return getndNode(theNo);
    }


    //获取正数第n个节点
    public HeroNode getndNode(int n) {

        if (n > getSize()) {
            System.out.println("该链表一共" + getSize() + "个元素");
            return null;
        }

        HeroNode temp = head;

        for (int i = 0; i < n; i++) {
            temp = temp.next;
        }

        return temp;
    }

    public int getSize() {
        HeroNode temp = head;
        int size = 0;

        while (true) {
            temp = temp.next;
            if (temp != null) {
                size++;
            } else {
                break;
            }
        }
        return size;
    }


    public void deleteHeroNodeByNo(int no) {

        HeroNode temp = head;

        while (true) {
            if (temp.next == null) {
                System.out.println("无对应no的heroNode");
                return;
            } else if (temp.next.no == no) {
                //找到
                temp.next = temp.next.next;
                break;
            }
            temp = temp.next;
        }
    }

    public void updateHeroNode(HeroNode heroNode) {
        HeroNode temp = head;

        while (true) {
            if (temp.next == null) {
                System.out.println("无对应no的heroNode");
                return;
            } else if (temp.next.no == heroNode.no) {
                //下面这种是对象引用修改
                heroNode.next = temp.next.next;
                temp.next = heroNode;
                break;

                // 下面这种是直接修改法
                /*temp.next.name = heroNode.name;
                temp.next.nickName = heroNode.nickName;
                break;*/
            }
            temp = temp.next;
        }
    }

    public void addByOrder(HeroNode heroNode) {

        HeroNode temp = head;
        //这个是表明是有已经拥有相同编号的HeroNode
        boolean isExistFlag = false;

        while (true) {
            if (temp.next == null) {
                break;
            }
            if (temp.next.no > heroNode.no) {
                break;
            } else if (temp.next.no == heroNode.no){
                //说明编号已经存在
                isExistFlag = true;
                break;
            } else {
                //需要往后移
                temp = temp.next;
            }
        }

        if (isExistFlag) {
            //说明已经存在
            System.out.println("已经存在");
        } else {
            //说明需要放在temp之前
            //这两句的顺序不能换
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }


    //添加节点到单向列表思路：找到当前链表的最后一个节点，使该节点的next指向新的节点即可
    public void add(HeroNode heroNode) {
        HeroNode temp = head;
        while (true) {
            if (temp.next == null) {
                //说明找到最后一个节点，即head即使最后一个节点
                temp.next = heroNode;
                break;
            }
            //如果不是空，则需要把节点往后移动一个
            temp = temp.next;
        }
    }

    public void showLinkedList() {
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //因为head不存储数据，所以直接从head.next开始即可
        HeroNode temp = head.next;
        while (true) {
            if (temp == null) {
                break;
            }
            System.out.println(temp);
            temp = temp.next;
        }
    }
}

class HeroNode {
    public int no;

    public String name;
    public String nickName;

    public HeroNode next;

    public HeroNode(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
//                ", next=" + next +
                '}';
    }
}
```



##### 双向链表

* 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。
* 单向链表不能自我删除，需要靠辅助节点(如果自我删除，那么前面的节点就无法和后面的节点连接起来了) ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点(认真体会).

```java
package im.bool.a03_linked_list;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/10 8:22 AM
 * #Desc   : 双向链表
 **/
public class a03_02_DoubleLinkedList {


    //双向链表的测试
    public static void main(String[] args) {

        //这个是按照添加顺序进行排序
        /*HeroNode heroNode01 = new HeroNode(1, "宋江", "及时雨");
        HeroNode heroNode02 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode heroNode03 = new HeroNode(3, "吴用", "智多星");
        HeroNode heroNode04 = new HeroNode(4, "林冲", "豹子头");

        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
        doubleLinkedList.add(heroNode01);
        doubleLinkedList.add(heroNode04);
        doubleLinkedList.add(heroNode02);
        doubleLinkedList.add(heroNode03);

        doubleLinkedList.showLinkedList();

        HeroNode heroNode004 = new HeroNode(4, "林冲0000", "豹子头");
        doubleLinkedList.updateHeroNode(heroNode004);
        System.out.println("update");
        doubleLinkedList.showLinkedList();

        doubleLinkedList.deleteHeroNodeByNo(4);
        System.out.println("delete");
        doubleLinkedList.showLinkedList();*/



        //这个是按照添加顺序进行排序
        HeroNode heroNode01 = new HeroNode(1, "宋江", "及时雨");
        HeroNode heroNode02 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode heroNode03 = new HeroNode(3, "吴用", "智多星");
        HeroNode heroNode04 = new HeroNode(4, "林冲", "豹子头");

        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
        doubleLinkedList.addByOrder(heroNode01);
        doubleLinkedList.addByOrder(heroNode04);
        doubleLinkedList.addByOrder(heroNode02);
        doubleLinkedList.addByOrder(heroNode03);

        doubleLinkedList.showLinkedList();

    }
}

class DoubleLinkedList {

    //先定义一个头节点，头节点什么都不存， 且不能改动
    private HeroNode head = new HeroNode(0, "", "");


    public void deleteHeroNodeByNo(int no) {

        if (head.next == null) {
            System.out.println("没有数据节点，也即是没有数据");
            return;
        }

        //这里直接找到需要删除的节点即可，不需要删除删除节点的前一个节点
        HeroNode temp = head.next;

        while (true) {
            if (temp == null) {
                System.out.println("无对应no的heroNode");
                return;
            } else if (temp.no == no) {
                //找到
                //把删除节点的前一个节点和删除节点的后一个节点连接起来，就相当于删除了当前节点，因为当前节点无引用，就会自动被清理。
                temp.pre.next = temp.next;
                //删除最后一个节点的时候，next可能为空
                if (temp.next != null) {
                    temp.next.pre = temp.pre;
                }
                break;
            }
            temp = temp.next;
        }
    }

    public void updateHeroNode(HeroNode heroNode) {
        HeroNode temp = head;

        while (true) {
            if (temp.next == null) {
                System.out.println("无对应no的heroNode");
                return;
            } else if (temp.no == heroNode.no) {
                //找到
                temp.pre.next = heroNode;
                heroNode.pre = temp.pre;
                heroNode.next = temp.next;
                temp.next.pre = heroNode;

//                temp.name = heroNode.name;
//                temp.nickName = heroNode.nickName;

                break;
            }
            temp = temp.next;
        }
    }

    public void addByOrder(HeroNode heroNode) {
        HeroNode temp = head;
        //这个是表明是有已经拥有相同编号的HeroNode
        boolean isExistFlag = false;

        while (true) {
            if (temp.next == null) {
                break;
            }
            if (temp.next.no > heroNode.no) {
                break;
            } else if (temp.next.no == heroNode.no){
                //说明编号已经存在
                isExistFlag = true;
                break;
            } else {
                //需要往后移
                temp = temp.next;
            }
        }

        if (isExistFlag) {
            //说明已经存在
            System.out.println("已经存在");
        } else {
            //说明需要放在temp之前
            //这两句的顺序不能换
            /*heroNode.next = temp.next;
            temp.next = heroNode;
            temp.next.pre = heroNode;
            heroNode.pre = temp;*/

            if (temp.next == null) {
                //说明需要放在最后面即可
                temp.next = heroNode;
                heroNode.pre = temp;
            } else {
                //先把heronode指向别人。
                heroNode.pre = temp;
                heroNode.next = temp.next;

                //再断开别人之间的连接，指向heronode
                temp.next.pre = heroNode;
                temp.next = heroNode;
            }
        }
    }



    //添加节点到单向列表思路：找到当前链表的最后一个节点，使该节点的next指向新的节点即可
    public void add(HeroNode heroNode) {
        HeroNode temp = head;
        while (true) {
            if (temp.next == null) {
                //说明找到最后一个节点，即head即使最后一个节点
                temp.next = heroNode;
                heroNode.pre = temp;
                break;
            }
            //如果不是空，则需要把节点往后移动一个
            temp = temp.next;

        }
    }

    public void showLinkedList() {
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //因为head不存储数据，所以直接从head.next开始即可
        HeroNode temp = head.next;
        while (true) {
            if (temp == null) {
                break;
            }
            System.out.println(temp);
            temp = temp.next;
        }
    }


    public HeroNode getHeadNode() {
        return head;
    }

}
```



##### 单向环形链表：约瑟夫问题

* 因为是单向，所以在出圈的时候，需要一个point指向出圈元素的前一个位置，不然没法把出圈元素踢出圈子

```java
package im.bool.a03_linked_list;

import java.util.ArrayList;
import java.util.List;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/10 3:36 PM
 * #Desc   : 约瑟夫问题解决-即单向环形列表
 **/
public class a03_03_Josepfu {

    public static void main(String[] args) {

        SingleCircleLinkedList circleLinkedList = new SingleCircleLinkedList();
        circleLinkedList.addBoy(5);

        circleLinkedList.showBoy();
        System.out.println("ivanl001");

        circleLinkedList.josepfuOrder(2, 3, 5);
    }
}

class SingleCircleLinkedList {

    //这个是个指针节点
    private Boy first = new Boy(-1);

    /*
     *startNo 开始的数字
     *countNum 数几下
     *nums 最开始一共有几个小孩在圈上
     */
    public void josepfuOrder(int startNo, int countNum, int nums) {

        //参数啥的我这里就不校验了
        List<Integer> theOrder = new ArrayList<Integer>();

        Boy boy = first;
        //还需要一个辅助指针，需要指向first前面一个指针，找到这个指针，需要正向移动一圈
        Boy pointer = first;
        while (true) {
            System.out.println("0000000000");
            if (pointer.getNext() == first) {
                break;
            }
            //如果pointer不是first的前一个，那么就接着往后移动
            pointer = pointer.getNext();
        }

        //因为是从startNo开始报数的，所以需要先移动startNo-1个位置
        for (int i = 0; i < startNo - 1; i++) {
            first = first.getNext();
            pointer = pointer.getNext();
        }

        //开始移动报数
        while (true) {
            //System.out.println("111111111");

            if (pointer == first) {
                System.out.println(first.getNo());
                //最后一个也要加一下，要不然就遗漏了
                theOrder.add(first.getNo());
                //说明后一个和前一个一样，圈中只有一个了
                break;
            }

            for (int i = 0; i < countNum - 1; i++) {
                first = first.getNext();
                pointer = pointer.getNext();
            }
            //循环结束，first节点即是要出圈的节点
            theOrder.add(first.getNo());
            //添加完这个需要把该boy从圈中去掉
            first = first.getNext();
            pointer.setNext(first);
        }
        System.out.println(theOrder);
    }


    public void showBoy() {
        Boy boy = first;
        while (true) {
            System.out.println(boy);

            if (boy.getNext() == first) {
                //说明已经循环一圈，可以跳出
                break;
            }
            boy = boy.getNext();
        }
    }


    public void addBoy(int nums) {
        if (nums < 1) {
            System.out.println("nums值不太正确");
            return;
        }

        //辅助指针，帮助构建环形链表
        Boy current = null;
        for (int i = 1; i <= nums; i++) {
            Boy boy = new Boy(i);

            if (i == 1) {
                first = boy;
                first.setNext(first);
                current = first;
            } else {
                current.setNext(boy);
                boy.setNext(first);
                current = boy;
            }
        }
    }
}

class Boy {

    private int no;
    private Boy next;

    public Boy(int no) {
        this.no = no;
    }
    public int getNo() {
        return no;
    }
    public void setNo(int no) {
        this.no = no;
    }
    public Boy getNext() {
        return next;
    }
    public void setNext(Boy next) {
        this.next = next;
    }
    @Override
    public String toString() {
        return "Boy{" +
                "no=" + no +
                '}';
    }
}
```



#### 1.4, 哈希表

HashTable是由数组和链表(或者红黑树)共同组成的一种数据结构.

通过hash来确定是数据所归属的链表。

![image-20210507101604582](https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210507101604582.png)

* 最下层是Student学生模型类
* 中间是链表模型，用户管理每个元素的添加和查找
* 上层是HashTable类，这个类包含一个链表数组，用于管理hash值



```java
package im.bool.a08_hash_table;

import java.util.Scanner;

/**
 * @author : 不二
 * @date : 2021/5/7-下午5:35
 * @desc : hashtable重新再写一遍
 **/
public class a08_01_HashTableDemo01 {

    public static void main(String[] args) {

        StudentHashTable table = new StudentHashTable(10);
        String key = "";
        Scanner scanner = new Scanner(System.in);
        while (true) {
            System.out.println("add: 添加雇员");
            System.out.println("list: 显示所有雇员");
            System.out.println("find: 查找雇员");
            System.out.println("exit: 退出系统");
            key = scanner.next();
            switch (key) {
                case "add":
                    System.out.println("输入id");
                    int id = scanner.nextInt();
                    System.out.println("输入名字");
                    String name = scanner.next();
                    // Employee employee = new Employee(id, name);
                    Student student = new Student(id, name);
                    table.addStudent(student);
                    break;
                case "list":
                    table.listHashTable();
                    break;
                case  "find":
                    System.out.println("请输入id");
                    int id01 = scanner.nextInt();
                    table.findStudentById(id01);
                    break;
                case "exit":
                    scanner.close();
                    System.exit(0);
                default:
                    break;
            }
        }
    }
}

class StudentHashTable {

    private int tableSize;
    private StudentLinkedList[] hashTable;

    public int hash(int id) {
        return id % tableSize;
    }
    public void addStudent(Student student) {
        hashTable[hash(student.getId())].addStudent(student);
    }
    public void listHashTable() {
        for (int i = 0; i < tableSize; i++) {
            hashTable[i].listStudents(i);
        }
    }

    public void findStudentById(int id) {
        hashTable[hash(id)].findStudentById(id);
    }
    public StudentHashTable() {
    }
    public StudentHashTable(int tableSize) {
        this.tableSize = tableSize;
        hashTable = new StudentLinkedList[this.tableSize];
        // 因为一个hashtable中有多个链表，
        // 上面是创建链表数组，但是数组中并没有任何数据。
        // 所以这里需要先对数组进行初始化方便后续直接调用链表的方法
        for (int i = 0; i < tableSize; i++) {
            hashTable[i] = new StudentLinkedList();
        }
    }
    public StudentHashTable(int tableSize, StudentLinkedList[] hashTable) {
        this.tableSize = tableSize;
        this.hashTable = hashTable;
    }
    public int getTableSize() {
        return tableSize;
    }
    public void setTableSize(int tableSize) {
        this.tableSize = tableSize;
    }
    public StudentLinkedList[] getHashTable() {
        return hashTable;
    }
    public void setHashTable(StudentLinkedList[] hashTable) {
        this.hashTable = hashTable;
    }
}

class StudentLinkedList {

    private Student head;

    public void addStudent(Student student) {
        if (head == null) {
            head = student;
            return;
        }
        Student current = head;
        while (current.next != null) {
            current = current.next;
        }
        current.next = student;
    }

    public void listStudents(int i) {
        i = i + 1;
        if (head == null) {
            System.out.println("当前链表序号为：" + i + ":当前链表为null");
        } else {
            System.out.printf("当前链表序号为：" + i + " ");

            Student current = head;
            while (current.next != null) {
                System.out.printf(head.getName() + "=>");
                current = current.next;
            }
            System.out.println(current.getName());
        }
    }

    public void findStudentById(int id) {
        if (head == null) {
            System.out.println("链表中无此id");
        } else {
            Student student = head;
            Student target = null;
            while (student != null) {
                if (student.getId() == id) {
                    target = student;
                    break;
                }
                student = student.next;
            }
            if (target != null) {
                System.out.println("根据id找到数据:id:" + target.getId() + ",name:" + target.getName());
            } else {
                System.out.println("链表中无此id");
            }

        }
    }
}

// 带有所有字段的getter和setter方法，并有空参构造器和满参构造器的java类--java bean
class Student {
    private int id;
    private String name;

    public Student next;

    public Student() {
    }

    public Student(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```



#### 1.5, 栈

* 栈的基本概念
  * 栈的英文为(stack)
  * 栈是一个先入后出(FILO-First In Last Out)的有序列表。
  * 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。
  * 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除



* 栈的应用
  * 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 	
  * 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
  * 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
  * 二叉树的遍历。
  * 图形的深度优先(depth一first)搜索法。



##### 栈模拟

* 数组模拟

```java
package im.bool.a04_stack;

import java.util.Arrays;
import java.util.Scanner;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/11 10:09 AM
 * #Desc   : 用数组模拟栈
 **/
public class a04_01_StackByArray {

    public static void main(String[] args) {

        ArrayStack stack = new ArrayStack(4);
        String key = "";
        boolean loop = true;
        Scanner scanner = new Scanner(System.in);

        while (loop) {
            System.out.println("show");
            System.out.println("exist");
            System.out.println("push");
            System.out.println("pop");
            System.out.println("请输入");
            key = scanner.next();
            if ("show".equals(key)) {
                stack.showStack();
            } else if ("exist".equals(key)) {
                scanner.close();
                loop = false;
            } else if ("push".equals(key)) {
                System.out.println("请输入一个数字：");
                int value = scanner.nextInt();
                stack.push(value);
                System.out.println("入栈完成");
            } else if ("pop".equals(key)) {
                int value01 = stack.pop();
                System.out.println("出栈的数字是：" + value01);
            } else {
                System.out.println("输入错误，请重新输入:");
                break;
            }
        }

    }
}

class ArrayStack {

    private int maxSize;
    private int[] stack;
    //入栈的时候position加1，出栈的时候position减1，这样子就可以模拟出先入的后出
    private int position = -1;

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    public boolean isFull() {
        return position == maxSize - 1;
    }

    public boolean isEmpty() {
        return position == -1;
    }

    public void push(int value) {
        if (isFull()) {
            System.out.println("full-----");
            return;
        }
        position++;
        stack[position] = value;
    }

    public int pop() {
        if (isEmpty()) {
            System.out.println("empty----");
            throw new RuntimeException("empty--");
        }

        int value = stack[position];
        position--;
        return value;
    }

    public void showStack() {
        if (isEmpty()) {
            System.out.println("empty");
            return;
        }
        for (int i = position; i >= 0; i--) {
            System.out.printf("stack[%d]=%d \n", i, stack[i]);
        }
    }
}
```



##### 栈实现计算器

```java
package im.bool.a04_stack;

import java.sql.Struct;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/16 8:57 PM
 * #Desc   : 通过栈摸模拟计算器
 **/
public class a04_02_Calculator {

    public static void main(String[] args) {


        String expStr = "111+2*6-2";

        //需要根据上面的字符串计算结果，需要创建两个栈：1，数栈  2，符号栈
        CalcArrayStack numStack = new CalcArrayStack(10);
        CalcArrayStack operStack = new CalcArrayStack(10);

        int index = 0;
        int num1 = 0;
        int num2 = 0;

        int oper = 0;
        int res = 0;
        char ch = ' ';

        String keepNum = "";//用于多位数字的通过字符拼接起来，才能正确的计算多位数

        while (true) {
            ch = expStr.substring(index, index + 1).charAt(0);

            if (operStack.isOper(ch)) {
                if (!operStack.isEmpty()) {
                    //说明符号栈中已经存在符号，需要根据两个符号的优先级进行处理
                    if (operStack.getPriority(ch) <= operStack.getPriority(operStack.peekTop())){
                        //说明当前符号的优先级小于栈中的优先级
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        int temp = numStack.cal(num1, num2, oper);
                        //然后把运算的结果入数栈
                        numStack.push(temp);
                        operStack.push(ch);
                    } else {
                        operStack.push(ch);
                    }
                } else {
                    //说明符号栈为空，那么直接把当前符号入栈即可
                    operStack.push(ch);
                }
            } else {
                //说明不是符号，而是数字，直接入数栈即可
                //因为字符型的数字，比如说1，其实字符型的时候是49
                //这个会有一个问题：只能计算<10,也就是只有一位数的值的计算
                //numStack.push(ch - 48);//这种就只能
                keepNum+=ch;

                if (index == expStr.length()-1) {
                    //说明已经是最后一个数字了
                    numStack.push(Integer.parseInt(keepNum)) ;
                    break;
                } else {
                    //判断下一个字符是不是符号，不是符号，需要继续，只有是符号后，才能入栈
                    if (operStack.isOper(expStr.substring(index+1, index+2).charAt(0))) {
                        //是符号为，那么可以入栈了
                        numStack.push(Integer.parseInt(keepNum));
                        keepNum = "";
                    }
                    //如果不是，那么就紧接着继续循环即可
                }

            }

            index++;

            if (index >= expStr.length()) {
                //说明已经是最后一个数字了
                break;
            }
        }

        //当表达式扫描完毕，就顺序的从数栈和符号栈中pop出对应的数字和符号，进行运算即可
        while (true) {
            if (operStack.isEmpty()) {
                break;
            }

            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            int temp = numStack.cal(num1, num2, oper);
            numStack.push(temp);
        }

        System.out.println("结果是：" + numStack.pop());
    }
}


class CalcArrayStack {

    private int maxSize;
    private int[] stack;
    //入栈的时候position加1，出栈的时候position减1，这样子就可以模拟出先入的后出
    private int position = -1;

    public CalcArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }


    public int peekTop() {
        return stack[position];
    }

    //计算方法，num1是先被出栈的数字，num2是后出栈的顺序，计算减法和除法的时候需要留意顺序
    public int cal(int num1, int num2, int oper) {
        int result = 0;
        switch (oper) {
            case '+':
                result = num1+num2;
                break;
            case '-':
                result = num2-num1;
                break;
            case '*':
                result = num1*num2;
                break;
            case '/':
                result = num2/num1;
                break;
        }
        return result;
    }


    //判断字符是不是运算符
    public boolean isOper(int val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    //优先级使用数字表示，数据越大，优先级越高.char类型可以和int类型相互转换的哈
    public int getPriority(int oper) {
        if (oper == '*' || oper == '/') {
            return 1;
        } else if (oper == '+' | oper == '-') {
            return 0;
        } else  {
            return -1;
        }
    }

    public boolean isFull() {
        return position == maxSize - 1;
    }

    public boolean isEmpty() {
        return position == -1;
    }

    public void push(int value) {
        if (isFull()) {
            System.out.println("full-----");
            return;
        }
        position++;
        stack[position] = value;
    }

    public int pop() {
        if (isEmpty()) {
            System.out.println("empty----");
            throw new RuntimeException("empty--");
        }

        int value = stack[position];
        position--;
        return value;
    }

    public void showStack() {
        if (isEmpty()) {
            System.out.println("empty");
            return;
        }
        for (int i = position; i >= 0; i--) {
            System.out.printf("stack[%d]=%d \n", i, stack[i]);
        }
    }
}
```



==-----------如下计算器以及波兰表达式内容后续有时间再看-------------==

#### 1.6, 计算器实现的波兰表达式和逆波兰表达式

#####  前缀表达式(波兰表达式)

> 波兰表达式又称前缀表达式，就是运算符位于操作数之前
>
> 举例说明： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6

```java
从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:

从右至左扫描，将6、5、4、3压入堆栈
遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈
接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈
最后是-运算符，计算出35-6的值，即29，由此得出最终结果
```





##### 中缀表达式(正常的计算表达式)

> 举例说明： (3+4)×5-6 就是中缀表达式



##### 后缀表达式(逆波兰表达式)

> 逆波兰表达式又称后缀表达式，与前缀表达式相似，只是运算符位于操作数之后
>
> 举例说明： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –
>
> | 中缀表达式 | 逆波兰表达式(后缀表达式) |
> | ---------- | ------------------------ |
> | a+b        | a b +                    |
> | a+(b-c)    | a b c - +                |
> | a+(b-c)*d  | a b c – d * +            |
> | a+d*(b-c)  | a d b c - * +            |
> | a=1+3      | a 1 3 + =                |

```java
后缀表达式的计算机求值

从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:

从左至右扫描，将3和4压入堆栈；
遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
将5入栈；
接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
将6入栈；
最后是-运算符，计算出35-6的值，即29，由此得出最终结果
```

```java
package im.bool.a04_stack;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/16 11:10 PM
 * #Desc   : 逆波兰表达式计算器:给定一个逆波兰表达式，计算出结果
 *。         如何把常用的正常的计算式子转换成逆波兰表达式可以看后面的内容
 **/
public class a04_03_ReversePolandNotation {

    public static void main(String[] args) {

        //先定义逆波兰表达式
        //(3+4)*5-6
        //String expStr = "3 4 + 5 × 6 - ";


        //4*5-8+60+8/2  4 5 * 8 - 60 + 8 2 / +
        String expStr = "4 5 × 8 - 60 + 8 2 / +";

        int result = calc(getListString(expStr));
        System.out.println("结果是: " + result);

    }


    public static List<String> getListString(String reversePolandNotionStr) {
        //把逆波兰表达式根据空格切开，然后放入数组方便后续进行计算
        List<String> elements = new ArrayList<String>();
        String[] splitExp = reversePolandNotionStr.split(" ");
        Collections.addAll(elements, splitExp);
        return elements;
    }

    /*
 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:

从左至右扫描，将3和4压入堆栈；
遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
将5入栈；
接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
将6入栈；
最后是-运算符，计算出35-6的值，即29，由此得出最终结果
     */
    public static int calc(List<String> elemets) {
        //创建栈
        Stack<String> stack = new Stack<String>();

        for (String item : elemets) {
            //使用正则表达式取出数字
            if (item.matches("\\d+")) {
                stack.push(item);
            } else {
                //如果不是数字，那么就pop出两个数字，进行运算，然后重新入栈
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());
                int result = 0;
                if (item.equals("+")) {
                    result = num1 + num2;
                } else if (item.equals("-")) {
                    result = num2 - num1;
                } else if (item.equals("×")) {
                    result = num1 * num2;
                } else if (item.equals("/")) {
                    result  = num2/num1;
                } else {
                    throw new RuntimeException("暂不支持的运算符号");
                }

                stack.push(result + "");
            }
        }

        //最终留在栈中的即是结果
        return Integer.parseInt(stack.pop());
    }
}
```



##### 中缀表达式转化为后缀表达式(逆波兰表达式)

* 这里感觉用处不大，知道了大致的内容，具体的代码就不写了。

==-----------如上计算器以及波兰表达式内容后续有时间再看-------------==

#### 1.7, 案例实战

> 下面实战中会使用到迭代(算法)，下面先简单学习一下

##### 迭代的基本应用

```java
package im.bool.a05_recursive_stack;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/23 9:06 AM
 * #Desc   : 迭代算法的一些基本应用
 **/
public class a05_01_Recursive {

    public static void main(String[] args) {

        //打印递归
        //这里打印10 9 8 7 6 5 4 3 2 1从大到小
//        printRecursively(10);
        //这里打印1 2 3 4 5 6 7 8 9 10从小到大
//        printRecursively01(10);
        //这里只会打印0
//        printRecursively02(10);

        //阶乘问题
        int factorial = factorial(10);
        System.out.println(factorial);

    }

    public static int factorial(int n) {
        if (n == 1) {
            return 1;
        } else {
            return factorial(n-1)*n;
        }
    }

    public static void printRecursively02(int n) {
        if (n >= 1) {
            printRecursively02(n-1);
        } else {
            System.out.println(n);
        }
    }

    public static void printRecursively01(int n) {
        if (n >= 1) {
            printRecursively01(n-1);
        }

        System.out.println(n);
    }

    public static void printRecursively(int n) {
        if (n >= 1) {
            System.out.println(n);
            printRecursively(n-1);
        }
    }
}
```



##### 迷宫问题

![image-20210424213042390](https://learningnotebookv1-1302566743.cos.ap-nanjing.myqcloud.com/img/image-20210424213042390.png)



```java
package im.bool.a05_recursive_stack;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/21 8:26 AM
 * #Desc   : 通过递归实现迷宫回溯问题
 **/
public class a05_02_Labyrinth {

    public static void main(String[] args) {

        //1, 模拟迷宫
        int[][] labyrinth = new int[8][7];

        //2, set column0 and column6 as wall
        for (int i = 0; i < 8; i++) {
            labyrinth[i][0] = 1;
            labyrinth[i][6] = 1;
        }

        //3, set row0 and row7 as wall
        for (int j = 0; j < 7; j++) {
           labyrinth[0][j] = 1;
           labyrinth[7][j] = 1;
        }

        //4, set special brick
        labyrinth[3][1] = 1;
        labyrinth[3][2] = 1;

        /*labyrinth[1][2] = 1;
        labyrinth[2][2] = 1;*/

        //5, 打印迷宫
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(labyrinth[i][j] + " ");
            }
            System.out.println();
        }

        //6, go through the labyrinth
        boolean finished = goThroughtLabyrinth(labyrinth, 1, 1);
        if (finished == true) {
            System.out.println("走出迷宫");
        } else {
            System.out.println("迷宫不通，是死的");
        }

        //7, see the map
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(labyrinth[i][j] + " ");
            }
            System.out.println();
        }
    }

    /**
     * @param labyrinth
     * @param i the start row
     * @param j the start column
     */
    private static boolean goThroughtLabyrinth(int[][] labyrinth, int i, int j) {
        if (labyrinth[6][5] == 2) {
            //get out of the exist
            System.out.println("find the exit");
            return true;
        } else {
            if (labyrinth[i][j] == 0) {
                //mark the way
                labyrinth[i][j] = 2;
                // follow the rule to go through the labyrinth
                //first go down , if not ok, go right, if not ok, go up, then go left
                if (goThroughtLabyrinth(labyrinth, i + 1, j) == true) {
                    return true;
                } else if (goThroughtLabyrinth(labyrinth, i, j + 1) == true) {
                    return true;
                } else if (goThroughtLabyrinth(labyrinth, i - 1, j) == true) {
                    return true;
                } else if (goThroughtLabyrinth(labyrinth, i, j - 1) == true) {
                    return true;
                } else {
                    labyrinth[i][j] = 3;
                    return false;
                }
            } else {
                return false;
            }
        }
    }
}
```



##### 八皇后问题

> * 当前行如果验证通过， 走下一行
> * 如果验证不通过， 先把当前行往后移，验证通过，走下一行，验证不通过， 就接着往后移。如果依然不通过， 依然往后移。直到超过8
> * 超过8的话， 那么就接着走上一行。结果是：要么通过， 然后走下一行，从0开始， 接着重新走。要么不通过，再回溯到上一行。 

```java
package im.bool.a05_recursive_stack;

/**
 * @author : 不二
 * @date : 2021/4/25-下午7:31
 * @desc : 八皇后问题算法
 * 卧槽， 这个太难了，看了视频， 没看明白， 画了图也没明白， 然后把代码嵌套写出来， 又画图，看了3个多小时才明白
 * 当前行如果验证通过， 走下一行
 * 如果验证不通过， 先把当前行往后移，验证通过，走下一行，验证不通过， 就接着往后移。如果依然不通过， 依然往后移。直到超过8
 * 超过8的话， 那么就回走上一行。结果是：要么通过， 然后走下一行，从0开始， 接着重新走。要么不通过，再回溯到上一行。
 * 
 **/
public class a05_03_Queue8 {

    public static void main(String[] args) {
        // 主方法
        a05_03_Queue8 queue8 = new a05_03_Queue8();
        queue8.check(0);
    }

    // 设置皇后个数
    int max = 8;
    // 定义一个数组, 分别保存第i行的位置 如：arr = {0, 4, 7, 5, 2, 6, 1, 3}
    // 索引表示第几行， 值表示该行上皇后放置在第几列0代表第0行，皇后放置在第0个位置
    int[] array = new int[max];

    // 开始放置内容
    // n是第几行
    private void check(int n) {
        // 说明n == 8 了， 八个皇后已经全部放好
        if (n == max) {
            // 这里调用的是我们自己写的打印结果的方法
            print();
            return;
        }

        for (int i = 0; i < max; i++) {
            array[n] = i;
            // 不冲突的话可以接着往上面一行放了
            if (judge(n)) {
                check(n + 1);
            }
            //如果冲突，就继续执行 array[n] = i; 即将第n个皇后，放置在本行得 后移的一个位置
        }
    }

    // 检测当前放置的皇后是否ok
    private boolean judge(int n) {
        // 因为需要判断跟前面所有的皇后是否冲突，所以需要循环
        // 说明
        //1. array[i] == array[n]  表示判断 第n个皇后是否和前面的n-1个皇后在同一列
        //2. Math.abs(n-i) == Math.abs(array[n] - array[i]) 表示判断第n个皇后是否和第i皇后是否在同一斜线
        // n = 1  放置第 2列 1 n = 1 array[1] = 1
        // Math.abs(1-0) == 1  Math.abs(array[n] - array[i]) = Math.abs(1-0) = 1
        //3. 判断是否在同一行, 没有必要，n 每次都在递增
        for (int i = 0; i < n; i++) {
            if (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) {
                return false;
            }
        }
        return true;
    }


    // 输出摆放位置
    private void print() {
        for (int i = 0; i < array.length; i++) {
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }
}
```



