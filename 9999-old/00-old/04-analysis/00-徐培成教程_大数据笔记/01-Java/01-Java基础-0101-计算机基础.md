计算机相关基础

0x0000001：0x表示是16进制，00000001表示每个0都代表一个16进制，最后一个是1，其余高位都是0，说明该数字是1



```java
0x0000001：0x表示是16进制，00000001表示每个0都代表一个16进制，最后一个是1，其余高位都是0，说明该数字是1

最高位是1，则是负数。最高位为0，则为正数
计算机中的数字二进制表示形式都是补码，正数的补码和原码一样，负数的补码
-1的表示形式：
11111111111111111111111111111111
+1的表示形式：
00000000000000000000000000000001

```



### 1.1, bit, byte, kb(kilobyte), MB(mega byte), Gigabyte
> bit是计算机存储的最小单位， 也就是一个二进制位
1 byte = 8 bit, 也就是一个字节等于8位，也就是2的8次方，也就是256，也就是说一个字节表示的是0-255个值

> 1 G = 1024 M = 1024 * 1024 KB = 1024 * 1024 * 1024 byte = 1024 * 1024 * 1024 * 8 bit

> 数据存储是以“字节”（Byte）为单位, 数据传输大多是以“位”（bit，又名“比特”）为单位

> 字符是指我们习惯的一个记录单位，比如说一个英文字符，一个数字字符，一个中文字符，一个日本字符等等， 字符在计算机中存的位数是根据编码方式和不同的字符类型的不同有所不同的，比如说ANSI中的字符采用8bit，一共可以表示255个不同的“字”，也即是一个字节，而UNICODE中的字符采用16bit，也就是两个字节，一共可以表示65535个不同的”字“，很明显前者是没办法把世界所有语言的”字“容纳进去的，比如说仅仅中国的汉字就不止255个，所以如果想要表示英文外的大多数语言，都必须要用到UNICODE编码

*以下是网络上的一些解释：详细解释可见：https://blog.csdn.net/guanfengliang1988/article/details/50440197*

```java
字符是各种文字和符号的总称，包括各个国家文字、标点符号、图形符号、数字等。字符集是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集有：ASCII字符集、ISO 8859字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。 
 
编码(encoding)和字符集不同。字符集只是字符的集合，不一定适合作网络传送、处理，有时须经编码(encode)后才能应用。如Unicode可依不同需要以UTF-8、UTF-16、UTF-32等方式编码。
 
字符编码就是以二进制的数字来对应字符集的字符。
 
因此，对字符进行编码，是信息交流的技术基础。
 
使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“字符集”。
规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码”。
 
各个国家和地区在制定编码标准的时候，“字符的集合”和“编码”一般都是同时制定的。因此，平常我们所说的“字符集”，比如：GB2312, GBK, JIS 等，除了有“字符的集合”这层含义外，同时也包含了“编码”的含义。
 
注意：Unicode字符集有多种编码方式，如UTF-8、UTF-16等；ASCII只有一种；大多数MBCS（包括GB2312）也只有一种。



ASCII第一次以规范标准的型态发表是在1967年，最后一次更新则是在1986年，至今为止共定义了128个字符；其中33个字符无法显示（这是以现今操作系统为依归，但在DOS模式下可显示出一些诸如笑脸、扑克牌花式等8-bit符号），且这33个字符多数都已是陈废的控制字符。控制字符的用途主要是用来操控已经处理过的文字。在33个字符之外的是95个可显示的字符，包含用键盘敲下空白键所产生的空白字符也算1个可显示字符（显示为空白）。
ASCII表：见http://zh.wikipedia.org/zh-cn/ASCII
 
ASCII缺点：
ASCII的最大缺点是只能显示26个基本拉丁字母、阿拉伯数目字和英式标点符号，因此只能用于显示现代美国英语（而且在处理英语当中的外来词如naïve、café、élite等等时，所有重音符号都不得不去掉，即使这样做会违反拼写规则）。而EASCII虽然解决了部份西欧语言的显示问题，但对更多其他语言依然无能为力。因此现在的苹果电脑已经抛弃ASCII而转用Unicode。
 
最早的英文DOS操作系统的系统内码是：ASCII。计算机这时候只支持英语，其他语言不能够在计算机存储和显示。

```

### 1.2, 位运算相关

* ⚠️：计算机中位运算的都是补码哈

> im.ivanl001.bigData.java_01.A01_BitOperationTest

> & 与运算，对齐位数，只要有一个为0就是0，都为1才等1， 所以0和任何的数与运算结果都为零

> | 或运算， 对齐位数，有一个是一就是一，否则为零

> ~ 按位取反，所有二进制的零变成一，一变成零
 所以-1的取反就是0， 0的取反就是1

> ^ 异或运算, 相同为零，不同为一，所以零和-1的异或运算结果是-1，因为所有位都不一样



```
10    0000 1010  => 10
5     0000 0101  => 5
&:    0000 0000  => 0
|:    0000 1111  => 15


0000 0000
1000 0001

0111 1110



0000 0001 
1111 1110

```

#### 1.2.1, 正负数的三码(可以理解成计算机中记录的数字都是补码，只不过正数补码和原码一样，不过负数是不同的)

 * 计算机中整数的原码，反码，补码都相同。
 * 负数的原码就是该十进制数的二进制写法，只不过首位的数字代表符号，0代表整数，1代表负数
   * 负数的反码是原码所有的0变为1,1变为0（解释以下这样做目的：运算中负数加正数其实就是两个正数的减法，但是减法在计算机中并不好表示，所以变成反码后就可以把负数加上正数这种类减法变成加法，只不过这样还是有一个小问题就是原码变反码就不是完全的减法变加法，中间还差了1，所以负数在计算机中存储的实际上是补码，看下面）
   * 负数的补码是负数的反码加一，加上一之后，负数(这里指补码)和正数的运算就和十进制的运算是等价的了
   

| -           | -    |      |      |      |      |      |      |      |
| ----------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| -1的原码    | 1000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0001 |
| -1的反码    | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1110 |
| `-1的补码`  | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 |
| 0的原反补码 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 |
| 1的原反补码 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0001 |
| ～1:        | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1110 |
| -2的原码    | 1000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0010 |
| -2的反码    | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1101 |
| -2的补码    | 1111 | 1111 | 1111 | 1111 | 111  | 1111 | 1111 | 1110 |

* 由-1的补码可知道：0和-1的^运算，因为所有位都不同，所以结果是-1，
* 由-1的补码可知道：0和-1的&运算，因为所有位都不同，所以结果是0
* ⚠️注意哦：最高位不参与反码补码的运算的，不过需要注意的是：～取反是会改变最高位符号的哦



## 计算机加减法演示：

* 我们这里用16进制表示哈
* 演示一下-10+5的计算
* 正数的原码，反码，补码都是一样的
* 负数的原码其他位和正数相同，最高以为为1表示负数
* 负数的反码是原码所有0变1，1变0后得到
* 负数的补码是反码+1，通过补1得到的
* ⚠️注意哦：最高位参不参与反码补码的运算的，不过需要注意的是：～取反是会改变最高位符号的哦
* 具体如下：

| -1                                              | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 |      |
| ----------------------------------------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 描述                                            |      |      |      |      |      |      |      |      |
| -10原码                                         | 1000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 1010 |
| -10的反码                                       | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 0101 |
| `-10的补码`                                     | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 0110 |
| 5的原码                                         | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0101 |
| 5的反码                                         | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0101 |
| `5的补码`                                       | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0101 |
|                                                 |      |      |      |      |      |      |      |      |
| -10的补码                                       | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 0110 |
| 5的补码                                         | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0101 |
| -10+5:就是-10的补码和5的补码进行+运算就可以了： | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1011 |
| 上面-10+5看似得到的不是-5                       |      |      |      |      |      |      |      |      |
| 但是负数在计算机中存的是补码                    |      |      |      |      |      |      |      |      |
| -5的原码                                        | 1000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0101 |
| -5的反码                                        | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1010 |
| `-5的补码`                                      | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1011 |
| 可以看到-10+5的结果就是-5的补码                 |      |      |      |      |      |      |      |      |
| 10的原码                                        | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 1010 |
| 10的反码                                        | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 1010 |
| 10的补码                                        | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 1010 |
| -5的补码                                        | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1111 | 1011 |
|                                                 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0000 | 0101 |



### 1.3，把int类型转成一个字节数组(因为int占据4个字节，所以字节数组长度为4即可)

```java
byte[] bytes = new byte[4];
//假设这个值是1,也就是00000000 0000000 00000000 00000001
int i = 128;
bytes[0] = (byte)i;//取最后四位//11111111
bytes[1] = (byte) (i >> 8);  //00000000
bytes[2] = (byte) (i >> 16); //00000000
bytes[3] = (byte) (i >> 24); //00000000
System.out.println("bytes[0]:"+bytes[0]);//因为是字节，而且所有位数都是1，那么这个字节直接打印出来就是-1
System.out.println("bytes[1]:"+bytes[1]);
System.out.println("bytes[2]:"+bytes[2]);
System.out.println("bytes[3]:"+bytes[3]);


//------------------再转换回去的时候就会有问题，因为涉及到不足到位数是补0还是补1的问题-------------------
//下面如何不&0xFF的话，127及小于127的数字，也即是小于2^7的数都ok，大于这个数就歇菜了
//如果是正数，类型转换位数增加的时候，前面是补0的，但是如果是负数，前面是补1，所以如果这个数小于128，也就是前7位填满，第8位表示符号，为0，如果第八位是1，那么这就是个负数，那么前面补1，就会有问题 所以这个时候用&符号的时候，可以纠正这个问题，&0xFF之后，其他位都是0，那么再进行移位就完全没有问题了

//----上面说的好像不是很对


////字节转整型的时候， 是保留符号的。所以128这样的，刚好bytes[0]最高位是1，那么就直接转换成-128，129的话，其他位也有，那么运算下来结果就偏离了
//如果是bytes[0]最高位不是1，比如大于等于256，小于32768，那么bytes[0]和bytes[1]最高位都不是1，那么就不会有问题
//如果是32768，这样的，bytes[1]最高位是1，那么也是一样的， 会转换成-32768
//反正就是int int_0 = (bytes[0]);字节转int的时候，最高位是1就会有影响
int int_0 = (bytes[0] & 0xFF);
int int_1 = (bytes[1] & 0xFF) << 8;
int int_2 = (bytes[2] & 0xFF) << 16;
int int_3 = (bytes[3] & 0xFF) << 24;
System.out.println("int_0   :" + int_0);
System.out.println("int_1   :" + int_1);
System.out.println("int_2   :" + int_2);
System.out.println("int_3   :" + int_3);

int resultInt = int_0 | int_1 | int_2 | int_3;
System.out.println(resultInt);
```

### 1.4，几个特殊的原码，反码和补码， 这里只讨论int类型

> 取反+1 : 符号位是不参与取反的

> int中最大值是0x7fffffff，也就是2^31-1=2147483647


> int中最大值+1，也就是0x7fffffff + 1的话，因为会越位，直接导致进到最大位上，最后结果是-2147483648

* 原因分析：0x7fffffff+1的直接后果是：1000 0000 0000 0000 0000 0000 0000 0000, 其实这个值应该是-0，但是计算机中已经有0000 0000 0000 0000 0000 0000 0000 0000表示0，再加一个-0是很明显的浪费行为，所以被这个值定为-2147483648

* 这样也就是计算机中数字闭合成一个圆，最大值+1为最小值，再接着加就可以重新回到0，回到最大值，这个是我自己瞎猜的，可能不是愿意图，哈哈
* 最大正值：0xfffffff
    * 原码：0111 1111 1111 1111 1111 1111 1111 1111
    * 反码：0111 1111 1111 1111 1111 1111 1111 1111
    * 补码：0111 1111 1111 1111 1111 1111 1111 1111
    * +1  ：1000 0000 0000 0000 0000 0000 0000 0000 //和下面的补码是一样的，其实也就是-0
    
* -2147483648:
    * 原码：1000 0000 0000 0000 0000 0000 0000 0000
    * 反码：1111 1111 1111 1111 1111 1111 1111 1111
    * 补码：1000 0000 0000 0000 0000 0000 0000 0000 //反码加1其实是进上去了，所以反推的时候好像推不回来

* 0 ：
    * 原码：0000 0000 0000 0000 0000 0000 0000 0000
    * 反码：0111 1111 1111 1111 1111 1111 1111 1111
    * 补码：1000 0000 0000 0000 0000 0000 0000 0000
    
* -1 ：
    * 原码：1000 0000 0000 0000 0000 0000 0000 0001
    * 反码：1111 1111 1111 1111 1111 1111 1111 1110
    * 补码：1111 1111 1111 1111 1111 1111 1111 1111

* 顺便看下两个int最大值相加是多少：
* 最大：0111 1111 1111 1111 1111 1111 1111 1111
* 最大：0111 1111 1111 1111 1111 1111 1111 1111
* 相加：1111 1111 1111 1111 1111 1111 1111 1110
* 相加之后是上面的那个值，那么看看原码是多少
* -1  ：1111 1111 1111 1111 1111 1111 1111 1101
* 取反：1000 0000 0000 0000 0000 0000 0000 0010
* 看到没，是-2
  





## 计算机位移运算

