[toc]





> 数据结构是算法的基础



## 1, 数据结构

### 1.1, 线性结构

> 数据元素之间存在一对一的关系



* 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系
* 线性结构有两种不同的存储结构，即**顺序存储结构**和**链式存储结构**。顺序存储的线性表称为顺序表，顺序表中的存储元素是连续的
* 链式存储的线性表称为链表，链表中的存储元素不一定是连续的，元素节点中存放数据元素以及相邻元素的地址信息
* 线性结构常见的有：数组、队列、链表和栈，

#### 1.1.1, 数组

##### 稀疏数组(sparseArray)

![image-20200203115045571](./asserts/image-20200203115045571.png)

```java
package im.bool;

/**
 * #Author : ivanl001
 * #Date   : 2019/11/2 14:12
 * #Desc   : 稀疏数组-棋盘的应用
 **/
public class a01_sparseArray {

    public static void main(String[] args) {

        //棋盘 11*11
        //0表示没有棋子，1表示黑子， 2表示蓝子
        int[][] chessArr = new int[11][11];
        chessArr[1][2] = 1;
        chessArr[2][3] = 2;
        chessArr[2][4] = 2;
        chessArr[3][4] = 2;

        System.out.println("原始棋盘二维数组是：------------------------------------");
        printArr(chessArr);
        /*for (int[] row : chessArr) {
            for (int num : row) {
                System.out.printf(num + "\t");
            }
            System.out.println("\n");
        }*/


        System.out.println("开始转换成稀疏数组：-------------------------------------");
        //1，先遍历二维数组，得到非0数据个数
        int sum = 0;
        for (int[] ints : chessArr) {
            for (int anInt : ints) {
                if (anInt != 0) {
                    sum++;
                }
            }
        }
        System.out.println("遍历之后获取到非零数据个数：" + sum);


         //2, 创建稀疏数组
        int[][] sparseArr = new int[1 + sum][3];

        //3, 给稀疏数组赋值
        //-------第一行是整体描述---------
        //说明原先数组有11行
        sparseArr[0][0] = 11;
        //说明原先数组有11列
        sparseArr[0][1] = 11;
        //说明原先数组有sum个不为零到数字
        sparseArr[0][2] = sum;
        //-------其余行是非零描述--------
        int count = 0;
        for (int i = 0; i < chessArr.length; i++) {
            for (int j = 0; j < chessArr[i].length; j++) {
                if (chessArr[i][j] != 0) {
                    count ++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = chessArr[i][j];

                }
            }
        }

        //打印稀疏数组
        System.out.println("稀疏数组是：");
        printArr(sparseArr);


        System.out.println("把稀疏数组转换回原始二维数组:----------------------------");
        int rowNum = sparseArr[0][0];
        int columnNum = sparseArr[0][1];
        int[][] theOriginalArr = new int[rowNum][columnNum];
        for (int i = 1; i < sparseArr.length; i++) {
            theOriginalArr[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }

        System.out.println("恢复后的二维数组是：---------------------------");
        printArr(theOriginalArr);
    }

    private static void printArr(int[][] arr){
        for (int[] row : arr) {
            for (int num : row) {
                System.out.printf(num + "\t");
            }
            System.out.println("\n");
        }
    }

}

```



#### 1.1.2, 队列

> 队列是一个有序列表， 可以用数组(顺序存储)或链表(链式存储)实现， FIFO

##### 数组模拟简单队列(单向队列)

* 数组模拟的队列会有队列容量限制，一旦超过指定数量就不能进行数据的添加。而且全部出列后不能进行队列的重用。
* 初始值：front = 0;rear = 0;

* 队列满条件：rear == maxSize
* 队列空条件：rear == front
* 添加数据rear后移：rear++;
* 获取数据，头部后移：front++;

```java
package im.bool;

import java.util.Scanner;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/8 11:41 AM
 * #Desc   : 这个把rear默认等于0， front也默认等于0，相当于环形队列初始值再重新做一下，好和环形队列逻辑基本一致
 **/
public class a02_queueByArray01 {

    public static void main(String[] args) {

        ArrayQueue01 queue = new im.bool.ArrayQueue01(3);
        char key = ' ';
        Scanner scanner = new Scanner(System.in);//
        boolean loop = true;
        while(loop) {
            System.out.println("s(show): 显示队列");
            System.out.println("e(exit): 退出");
            System.out.println("a(add): 添加队列");
            System.out.println("g(get): 获取");
            System.out.println("h(head): 显示头部数据");
            System.out.println("i(info): 显示头部数据");
            key = scanner.next().charAt(0);
            switch (key) {
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输入数据：");
                    int value = scanner.nextInt();
                    queue.addToQueue(value);
                    break;
                case 'g':
                    try {
                        int res = queue.getDataFromQueue();
                        System.out.println("数据是：\n" + res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':
                    try {
                        int res = queue.showHeadData();
                        System.out.printf("头部数据是：%d\n", res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'i':
                    try {
                        queue.showInfo();
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出");
    }

}


class ArrayQueue01 {

    //队列最大容量
    private int maxSize;
    //队列第一个位置
    private int front;
    //队列最后一个元素位置
    private int rear;

    //存放数据的地方，模拟队列
    private int[] arr;

    //这个是构造方法
    public ArrayQueue01(int maxSize) {
        this.maxSize = maxSize;
        arr = new int[maxSize];
        //这里都定义成0，代表执行队列头部
        front = 0;
        rear = 0;
    }

    public void addToQueue(int n) {
        if (isFull()) {
            System.out.println("队列已满，不能添加数据");
            return;
        }
        //先赋值然后再后移
        arr[rear] = n;
        rear++;
    }

    //判断队列是否满了
    public boolean isFull() {
        return rear == maxSize;
    }

    public boolean isEmpty() {
        return rear == front;
    }

    public int getDataFromQueue() {
        if (isEmpty()) {
            System.out.println("队列为空，不可取数据");
            throw new RuntimeException("队列为空异常");
        }
        int data = arr[front];
        front++;
        return data;
    }

    //显示队列的所有数据
    public void showQueue() {
        if (isEmpty()) {
            System.out.println("队列为空，直接返回");
            return;
        }

        for (int i = front; i < arr.length; i++) {
            System.out.println("arr[" + i + "]=" + arr[i]);
        }
    }

    //显示队列的头部数据，这里只显示，不取
    public Integer showHeadData() {
        if (isEmpty()) {
            System.out.println("队列为空，直接返回");
            return null;
        }

        return arr[front + 1];

    }


    public void showInfo() {
        System.out.println("front=" + front);
        System.out.println("rear=" + rear);
    }
}

```

==张==



##### 数组模拟环形队列(需要用到一些算法)

* 初始值：front = 0;rear = 0;

* 队列满条件：(rear+1)%maxSize==front， 因为是环形队列， 能循环使用，所以不能直接rear=front，因为默认空的时候也满足这个条件。所以只能空一个数据出来，这样只有数据满的时候才会满足(rear+1)%maxSize==front
* 队列空条件：rear == front
* 添加数据rear后移：rear = (rear+1)%maxSize;
* 获取数据，头部后移：front = (front+1)%maxSize;

```java
package im.bool;

import com.sun.org.apache.regexp.internal.RE;

import java.util.Scanner;

/**
 * #Author : ivanl001
 * #Date   : 2019/11/9 14:46
 * #Desc   : 数组模拟成环形队列
 * 思路分析：之前的数组模拟简单队列：front表示头部，指向队列的队列的前一个位置， rear表示尾部。
 *         模拟环形队列需要把front改变一下， front执行队列的第一个元素
 *         rear也要改变一下，rear指向队列最后一个元素。因为希望空出一个空间作为约定。
 *         那么当队列满时候，则：rear+1-front = maxSize
 **/
public class a03_circleQueueByArray {

    public static void main(String[] args) {

        CircleArray queue = new CircleArray(3);
        char key = ' ';
        Scanner scanner = new Scanner(System.in);//
        boolean loop = true;
        while(loop) {
            System.out.println("s(show): 显示队列");
            System.out.println("e(exit): 退出");
            System.out.println("a(add): 添加队列");
            System.out.println("g(get): 获取");
            System.out.println("h(head): 显示头部数据");
            System.out.println("i(info): 显示头部数据");

            key = scanner.next().charAt(0);
            switch (key) {
                case 's':
                    queue.showQueue();
                    break;
                case 'a':
                    System.out.println("输入数据：");
                    int value = scanner.nextInt();
                    queue.addToQueue(value);
                    break;
                case 'g':
                    try {
                        int res = queue.getDataFromQueue();
                        System.out.println("数据是：\n" + res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':
                    try {
                        int res = queue.showHeadData();
                        System.out.printf("头部数据是：%d\n", res);
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'i':
                    try {
                        queue.showInfo();
                    } catch (Exception e) {
                        // TODO: handle exception
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序退出");
    }

}


class CircleArray {

    private int maxSize;
    //front初始值为0
    private int front;
    //rear初始值为0
    private int rear;
    private int[] arr;


    public CircleArray(int arrMaxSize) {
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        //下一个位置，也就是元素的后面一个位置
        front = 0;
        rear = 0;
    }

    //添加数据到队列
    public void addToQueue(int n) {
        //判断是否满,这个是移动前判断，所以不论何时，队列中至少会有一个位置会空出来。
        if (isFull()) {
            System.out.println("队列已满，不能添加到队列");
            return;
        }
        arr[rear] = n;
        //rear++; //rear后移一位,判断是否满其实就是判断后移这一位之后会不会等于front，等于说明满了。
        rear = (rear+1)%maxSize;
    }

    //判读是否队列已满
    public boolean isFull() {
        return (rear+1)%maxSize==front;
    }

    public int getDataFromQueue() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空，不能取数据");
        }

        int value = arr[front];
        front = (front+1)%maxSize;
        return value;
    }

    //判断队列是否为空
    public boolean isEmpty() {
        return rear == front;
    }

    //显示队列方法
    public void showQueue(){
        //
        if (isEmpty()) {
            System.out.println("队列为空， 没有数据～～");
            return;
        }

        //环形队列不一定是从0开始有数据，所以需要从front遍历， 遍历数据个数是(rear-front)%maxSize
        for (int i = front; i < front + (rear+maxSize-front)%maxSize; i++) {
            System.out.printf("arr[%d]=%d\n", i%maxSize, arr[i%maxSize]);
        }
    }

    public int showHeadData() {
        if (isEmpty()) {
            throw new RuntimeException("队列为空， 无数据");
        }
        return arr[front];
    }

    public void showInfo() {
        System.out.println("front=" + front);
        System.out.println("rear=" + rear);
    }
}

```



#### 1.1.3, 链表

> 链表是以节点的方式来存储,是链式存储
> 每个节点包含 data 域， next 域：指向下一个节点.
> 如图：发现链表的各个节点不一定是连续存储.
> 链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定



##### 单向链表

* 如下代码中链表包含一个头节点，改节点作为定位节点，不存储任何数据信息

* 如下代码包含链表的创建， 新增，更改，删除等等

```java
package im.bool.a03_linked_list;

import java.util.Stack;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/8 5:43 PM
 * #Desc   : 一个简单的单向链表的实现
 **/
public class a03_01_singleLinkedList {

    public static void main(String[] args) {

        //这个是按照添加顺序进行排序
        HeroNode heroNode01 = new HeroNode(1, "宋江", "及时雨");
        HeroNode heroNode02 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode heroNode03 = new HeroNode(3, "吴用", "智多星");
        HeroNode heroNode04 = new HeroNode(4, "林冲", "豹子头");

        SingleLinkedList singleLinkedList = new SingleLinkedList();
        singleLinkedList.add(heroNode01);
        singleLinkedList.add(heroNode04);
        singleLinkedList.add(heroNode02);
        singleLinkedList.add(heroNode03);

        singleLinkedList.showLinkedList();

        /*singleLinkedList.reverse();
        System.out.println("逆序");
        singleLinkedList.showLinkedList();*/

        System.out.println("逆序打印，不会改变原始结构");
        singleLinkedList.printDesc();


        //这个是按照英雄编号进行排序，跟添加顺序无关
        /*HeroNode heroNode01 = new HeroNode(1, "宋江", "及时雨");
        HeroNode heroNode02 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode heroNode03 = new HeroNode(3, "吴用", "智多星");
        HeroNode heroNode04 = new HeroNode(4, "林冲", "豹子头");

        SingleLinkedList singleLinkedList = new SingleLinkedList();

        System.out.println(singleLinkedList.getSize());

        singleLinkedList.addByOrder(heroNode01);
        singleLinkedList.addByOrder(heroNode03);
        singleLinkedList.addByOrder(heroNode03);
        singleLinkedList.addByOrder(heroNode02);
        singleLinkedList.addByOrder(heroNode04);

        singleLinkedList.showLinkedList();*/



        /*System.out.println(singleLinkedList.getSize());

        System.out.println(singleLinkedList.getndNode(4));

        System.out.println("--------------");
        System.out.println(singleLinkedList.getLstndNode(3));*/



        /*heroNode01 = new HeroNode(3, "zhangdanfeng", "及时雨");
        singleLinkedList.updateHeroNode(heroNode01);
        singleLinkedList.showLinkedList();

        System.out.println("-------------------------");
        singleLinkedList.deleteHeroNodeByNo(3);
        singleLinkedList.showLinkedList();

        System.out.println("-------------------------");
        singleLinkedList.deleteHeroNodeByNo(2);
        singleLinkedList.showLinkedList();

        System.out.println("-------------------------");
        singleLinkedList.deleteHeroNodeByNo(1);
        singleLinkedList.deleteHeroNodeByNo(1);
        singleLinkedList.showLinkedList();


        System.out.println("-------------------------");
        singleLinkedList.deleteHeroNodeByNo(4);
        singleLinkedList.showLinkedList();


        System.out.println("-------------------------");
        singleLinkedList.deleteHeroNodeByNo(5);
        singleLinkedList.showLinkedList();*/

    }
}

class SingleLinkedList {
    //先定义一个头节点，头节点什么都不存， 且不能改动
    private HeroNode head = new HeroNode(0, "", "");


    //面试题：逆序打印单链表的节点
    //先遍历，取出来后放入栈中，然后逐步pop出来即可
    public void printDesc() {

        if (head.next == null) {
            System.out.println("空链表");
            return;
        }

        Stack<HeroNode> heroNodes = new Stack<HeroNode>();

        HeroNode temp = head.next;
        while (temp != null) {
            heroNodes.push(temp);
            temp = temp.next;
        }

        while (heroNodes.size() > 0) {
            System.out.println(heroNodes.pop());
        }
    }



    //面试题：单链表的反转
    //思路：1，链表只要有头节点head，通过head可以找到完成的链表
    //2, 先新建一个临时tempHead，把head的下一个节点node1，剪切放入到临时链表的头节点后面。
    //3, 然后head的下一个节点，也就是原先链表的第二个节点node2，成为了原先链表的第一个节点，重复2，也就是剪切放入到临时链表的头节点的后面，也就是tempHead和node1中间，然后就变成临时节点的倒数第二个节点了
    //4, 重复上面的步骤， 直到原链表head后面的节点全部在临时链表中排序好
    //5, 最后把临时链表中的数据，赋值给head即可
    public void reverse() {

        if (head.next == null || head.next.next == null) {
            System.out.println("无数据库或者数据仅有1个，无需反转即使正确的");
            return;
        }

        //定义一些辅助变量指针，帮我们遍历原来的链表
        HeroNode current = head.next;
        HeroNode next;
        //这个头是先用来把数据排好序，最后再把排好序的数据部分赋值给head
        HeroNode tempHead = new HeroNode(0, "", "");

        while (current != null) {
            next = current.next;//先暂时保存current节点的下一个节点，要不到时候就找不到进入口了。因为current到时候会给temp，到时候current的next就会变掉了

            //把current夹在新的排序的链表head节点紧着后面，依次下来之后就相当于反转了。
            current.next = tempHead.next;
            tempHead.next = current;

            //再把原先的链表删除掉已经添加到新的链表中的那个节点
            current = next;
        }

        //最后把排序的链表重新赋值给原链表即可
        head.next = tempHead.next;
        //到这里原链表就被拷贝到新的链表上排好序，又给赋值回来了
    }




    //获取倒数第n个节点
    public HeroNode getLstndNode(int n) {
        if (n > getSize()) {
            System.out.println("该链表一共" + getSize() + "个元素");
            return null;
        }

        int theNo = getSize() - n + 1;
        return getndNode(theNo);
    }


    //获取正数第n个节点
    public HeroNode getndNode(int n) {

        if (n > getSize()) {
            System.out.println("该链表一共" + getSize() + "个元素");
            return null;
        }

        HeroNode temp = head;

        for (int i = 0; i < n; i++) {
            temp = temp.next;
        }

        return temp;
    }

    public int getSize() {
        HeroNode temp = head;
        int size = 0;

        while (true) {
            temp = temp.next;
            if (temp != null) {
                size++;
            } else {
                break;
            }
        }
        return size;
    }


    public void deleteHeroNodeByNo(int no) {

        HeroNode temp = head;

        while (true) {
            if (temp.next == null) {
                System.out.println("无对应no的heroNode");
                return;
            } else if (temp.next.no == no) {
                //找到
                temp.next = temp.next.next;
                break;
            }
            temp = temp.next;
        }
    }

    public void updateHeroNode(HeroNode heroNode) {
        HeroNode temp = head;

        while (true) {
            if (temp.next == null) {
                System.out.println("无对应no的heroNode");
                return;
            } else if (temp.next.no == heroNode.no) {
                //找到
                //temp.next = temp.next.next;
                heroNode.next = temp.next.next;
                temp.next = heroNode;
                break;
            }
            temp = temp.next;
        }
    }

    public void addByOrder(HeroNode heroNode) {

        HeroNode temp = head;
        //这个是表明是有已经拥有相同编号的HeroNode
        boolean isExistFlag = false;

        while (true) {
            if (temp.next == null) {
                break;
            }
            if (temp.next.no > heroNode.no) {
                break;
            } else if (temp.next.no == heroNode.no){
                //说明编号已经存在
                isExistFlag = true;
                break;
            } else {
                //需要往后移
                temp = temp.next;
            }
        }

        if (isExistFlag) {
            //说明已经存在
            System.out.println("已经存在");
        } else {
            //说明需要放在temp之前
            //这两句的顺序不能换
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }


    //添加节点到单向列表思路：找到当前链表的最后一个节点，使该节点的next指向新的节点即可
    public void add(HeroNode heroNode) {
        HeroNode temp = head;
        while (true) {
            if (temp.next == null) {
                //说明找到最后一个节点，即head即使最后一个节点
                temp.next = heroNode;
                break;
            }
            //如果不是空，则需要把节点往后移动一个
            temp = temp.next;
        }
    }

    public void showLinkedList() {
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //因为head不存储数据，所以直接从head.next开始即可
        HeroNode temp = head.next;
        while (true) {
            if (temp == null) {
                break;
            }
            System.out.println(temp);
            temp = temp.next;
        }
    }
}

class HeroNode {
    public int no;

    public String name;
    public String nickName;

    public HeroNode next;

    public HeroNode(int no, String name, String nickName) {
        this.no = no;
        this.name = name;
        this.nickName = nickName;
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "no=" + no +
                ", name='" + name + '\'' +
                ", nickName='" + nickName + '\'' +
//                ", next=" + next +
                '}';
    }
}

```



##### 双向链表

* 单向链表，查找的方向只能是一个方向，而双向链表可以向前或者向后查找。
* 单向链表不能自我删除，需要靠辅助节点(如果自我删除，那么前面的节点就无法和后面的节点连接起来了) ，而双向链表，则可以自我删除，所以前面我们单链表删除时节点，总是找到temp,temp是待删除节点的前一个节点(认真体会).

```java
package im.bool.a03_linked_list;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/10 8:22 AM
 * #Desc   : 双向链表
 **/
public class a03_02_DoubleLinkedList {


    //双向链表的测试
    public static void main(String[] args) {

        //这个是按照添加顺序进行排序
        /*HeroNode heroNode01 = new HeroNode(1, "宋江", "及时雨");
        HeroNode heroNode02 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode heroNode03 = new HeroNode(3, "吴用", "智多星");
        HeroNode heroNode04 = new HeroNode(4, "林冲", "豹子头");

        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
        doubleLinkedList.add(heroNode01);
        doubleLinkedList.add(heroNode04);
        doubleLinkedList.add(heroNode02);
        doubleLinkedList.add(heroNode03);

        doubleLinkedList.showLinkedList();

        HeroNode heroNode004 = new HeroNode(4, "林冲0000", "豹子头");
        doubleLinkedList.updateHeroNode(heroNode004);
        System.out.println("update");
        doubleLinkedList.showLinkedList();

        doubleLinkedList.deleteHeroNodeByNo(4);
        System.out.println("delete");
        doubleLinkedList.showLinkedList();*/



        //这个是按照添加顺序进行排序
        HeroNode heroNode01 = new HeroNode(1, "宋江", "及时雨");
        HeroNode heroNode02 = new HeroNode(2, "卢俊义", "玉麒麟");
        HeroNode heroNode03 = new HeroNode(3, "吴用", "智多星");
        HeroNode heroNode04 = new HeroNode(4, "林冲", "豹子头");

        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
        doubleLinkedList.addByOrder(heroNode01);
        doubleLinkedList.addByOrder(heroNode04);
        doubleLinkedList.addByOrder(heroNode02);
        doubleLinkedList.addByOrder(heroNode03);

        doubleLinkedList.showLinkedList();

    }
}

class DoubleLinkedList {

    //先定义一个头节点，头节点什么都不存， 且不能改动
    private HeroNode head = new HeroNode(0, "", "");


    public void deleteHeroNodeByNo(int no) {

        if (head.next == null) {
            System.out.println("没有数据节点，也即是没有数据");
            return;
        }

        //这里直接找到需要删除的节点即可，不需要删除删除节点的前一个节点
        HeroNode temp = head.next;

        while (true) {
            if (temp == null) {
                System.out.println("无对应no的heroNode");
                return;
            } else if (temp.no == no) {
                //找到
                //把删除节点的前一个节点和删除节点的后一个节点连接起来，就相当于删除了当前节点，因为当前节点无引用，就会自动被清理。
                temp.pre.next = temp.next;
                //删除最后一个节点的时候，next可能为空
                if (temp.next != null) {
                    temp.next.pre = temp.pre;
                }
                break;
            }
            temp = temp.next;
        }
    }

    public void updateHeroNode(HeroNode heroNode) {
        HeroNode temp = head;

        while (true) {
            if (temp.next == null) {
                System.out.println("无对应no的heroNode");
                return;
            } else if (temp.no == heroNode.no) {
                //找到
                //temp.next = temp.next.next;
                /*heroNode.next = temp.next.next;
                temp.next = heroNode;*/

                temp.name = heroNode.name;
                temp.nickName = heroNode.nickName;

                break;
            }
            temp = temp.next;
        }
    }

    public void addByOrder(HeroNode heroNode) {
        HeroNode temp = head;
        //这个是表明是有已经拥有相同编号的HeroNode
        boolean isExistFlag = false;

        while (true) {
            if (temp.next == null) {
                break;
            }
            if (temp.next.no > heroNode.no) {
                break;
            } else if (temp.next.no == heroNode.no){
                //说明编号已经存在
                isExistFlag = true;
                break;
            } else {
                //需要往后移
                temp = temp.next;
            }
        }

        if (isExistFlag) {
            //说明已经存在
            System.out.println("已经存在");
        } else {
            //说明需要放在temp之前
            //这两句的顺序不能换
            /*heroNode.next = temp.next;
            temp.next = heroNode;
            temp.next.pre = heroNode;
            heroNode.pre = temp;*/

            if (temp.next == null) {
                //说明需要放在最后面即可
                temp.next = heroNode;
                heroNode.pre = temp;
            } else {
                //先把heronode指向别人。
                heroNode.pre = temp;
                heroNode.next = temp.next;

                //再断开别人之间的连接，指向heronode
                temp.next.pre = heroNode;
                temp.next = heroNode;
            }
        }
    }



    //添加节点到单向列表思路：找到当前链表的最后一个节点，使该节点的next指向新的节点即可
    public void add(HeroNode heroNode) {
        HeroNode temp = head;
        while (true) {
            if (temp.next == null) {
                //说明找到最后一个节点，即head即使最后一个节点
                temp.next = heroNode;
                heroNode.pre = temp;
                break;
            }
            //如果不是空，则需要把节点往后移动一个
            temp = temp.next;

        }
    }

    public void showLinkedList() {
        if (head.next == null) {
            System.out.println("链表为空");
            return;
        }
        //因为head不存储数据，所以直接从head.next开始即可
        HeroNode temp = head.next;
        while (true) {
            if (temp == null) {
                break;
            }
            System.out.println(temp);
            temp = temp.next;
        }
    }


    public HeroNode getHeadNode() {
        return head;
    }

}
```



##### 单向环形列表：约瑟夫问题

* 因为是单向，所以在出圈的时候，需要一个point指向出圈元素的前一个位置，不然没法把出圈元素踢出圈子

```java
package im.bool.a03_linked_list;

import java.util.ArrayList;
import java.util.List;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/10 3:36 PM
 * #Desc   : 约瑟夫问题解决-即单向环形列表
 **/
public class a03_03_Josepfu {

    public static void main(String[] args) {

        SingleCircleLinkedList circleLinkedList = new SingleCircleLinkedList();
        circleLinkedList.addBoy(5);

        circleLinkedList.showBoy();
        System.out.println("ivanl001");

        circleLinkedList.josepfuOrder(2, 3, 5);
    }
}

class SingleCircleLinkedList {

    //这个是个指针节点
    private Boy first = new Boy(-1);

    /*
     *startNo 开始的数字
     *countNum 数几下
     *nums 最开始一共有几个小孩在圈上
     */
    public void josepfuOrder(int startNo, int countNum, int nums) {

        //参数啥的我这里就不校验了
        List<Integer> theOrder = new ArrayList<Integer>();

        Boy boy = first;
        //还需要一个辅助指针，需要指向first前面一个指针，找到这个指针，需要正向移动一圈
        Boy pointer = first;
        while (true) {
            System.out.println("0000000000");
            if (pointer.getNext() == first) {
                break;
            }
            //如果pointer不是first的前一个，那么就接着往后移动
            pointer = pointer.getNext();
        }

        //因为是从startNo开始报数的，所以需要先移动startNo-1个位置
        for (int i = 0; i < startNo - 1; i++) {
            first = first.getNext();
            pointer = pointer.getNext();
        }

        //开始移动报数
        while (true) {
            //System.out.println("111111111");

            if (pointer == first) {
                System.out.println(first.getNo());
                //最后一个也要加一下，要不然就遗漏了
                theOrder.add(first.getNo());
                //说明后一个和前一个一样，圈中只有一个了
                break;
            }

            for (int i = 0; i < countNum - 1; i++) {
                first = first.getNext();
                pointer = pointer.getNext();
            }
            //循环结束，first节点即是要出圈的节点
            theOrder.add(first.getNo());
            //添加完这个需要把该boy从圈中去掉
            first = first.getNext();
            pointer.setNext(first);
        }
        System.out.println(theOrder);
    }


    public void showBoy() {
        Boy boy = first;
        while (true) {
            System.out.println(boy);

            if (boy.getNext() == first) {
                //说明已经循环一圈，可以跳出
                break;
            }
            boy = boy.getNext();
        }
    }


    public void addBoy(int nums) {
        if (nums < 1) {
            System.out.println("nums值不太正确");
            return;
        }

        //辅助指针，帮助构建环形链表
        Boy current = null;
        for (int i = 1; i <= nums; i++) {
            Boy boy = new Boy(i);

            if (i == 1) {
                first = boy;
                first.setNext(first);
                current = first;
            } else {
                current.setNext(boy);
                boy.setNext(first);
                current = boy;
            }
        }
    }
}

class Boy {

    private int no;
    private Boy next;

    public Boy(int no) {
        this.no = no;
    }
    public int getNo() {
        return no;
    }
    public void setNo(int no) {
        this.no = no;
    }
    public Boy getNext() {
        return next;
    }
    public void setNext(Boy next) {
        this.next = next;
    }
    @Override
    public String toString() {
        return "Boy{" +
                "no=" + no +
                '}';
    }
}
```



#### 1.1.4, 栈

> 栈的基本概念

* 栈的英文为(stack)
* 栈是一个先入后出(FILO-First In Last Out)的有序列表。
* 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。
* 根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除



> 栈的应用

* 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中，直到子程序执行完后再将地址取出，以回到原来的程序中。 	
* 处理递归调用：和子程序的调用类似，只是除了储存下一个指令的地址外，也将参数、区域变量等数据存入堆栈中。
* 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。
* 二叉树的遍历。
* 图形的深度优先(depth一first)搜索法。



##### 数组模拟栈

```java
package im.bool.a04_stack;

import java.util.Arrays;
import java.util.Scanner;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/11 10:09 AM
 * #Desc   : 用数组模拟栈
 **/
public class a04_01_StackByArray {

    public static void main(String[] args) {

        ArrayStack stack = new ArrayStack(4);
        String key = "";
        boolean loop = true;
        Scanner scanner = new Scanner(System.in);

        while (loop) {
            System.out.println("show");
            System.out.println("exist");
            System.out.println("push");
            System.out.println("pop");
            System.out.println("请输入");
            key = scanner.next();
            if ("show".equals(key)) {
                stack.showStack();
            } else if ("exist".equals(key)) {
                scanner.close();
                loop = false;
            } else if ("push".equals(key)) {
                System.out.println("请输入一个数字：");
                int value = scanner.nextInt();
                stack.push(value);
                System.out.println("入栈完成");
            } else if ("pop".equals(key)) {
                int value01 = stack.pop();
                System.out.println("出栈的数字是：" + value01);
            } else {
                System.out.println("输入错误，请重新输入:");
                break;
            }
        }

    }
}

class ArrayStack {

    private int maxSize;
    private int[] stack;
    //入栈的时候position加1，出栈的时候position减1，这样子就可以模拟出先入的后出
    private int position = -1;

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    public boolean isFull() {
        return position == maxSize - 1;
    }

    public boolean isEmpty() {
        return position == -1;
    }

    public void push(int value) {
        if (isFull()) {
            System.out.println("full-----");
            return;
        }
        position++;
        stack[position] = value;
    }

    public int pop() {
        if (isEmpty()) {
            System.out.println("empty----");
            throw new RuntimeException("empty--");
        }

        int value = stack[position];
        position--;
        return value;
    }

    public void showStack() {
        if (isEmpty()) {
            System.out.println("empty");
            return;
        }
        for (int i = position; i >= 0; i--) {
            System.out.printf("stack[%d]=%d \n", i, stack[i]);
        }
    }
}
```



##### 通过自写栈实现简单计算器

```java
package im.bool.a04_stack;

import java.sql.Struct;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/16 8:57 PM
 * #Desc   : 通过栈摸模拟计算器
 **/
public class a04_02_Calculator {

    public static void main(String[] args) {


        String expStr = "111+2*6-2";

        //需要根据上面的字符串计算结果，需要创建两个栈：1，数栈  2，符号栈
        CalcArrayStack numStack = new CalcArrayStack(10);
        CalcArrayStack operStack = new CalcArrayStack(10);

        int index = 0;
        int num1 = 0;
        int num2 = 0;

        int oper = 0;
        int res = 0;
        char ch = ' ';

        String keepNum = "";//用于多位数字的通过字符拼接起来，才能正确的计算多位数

        while (true) {
            ch = expStr.substring(index, index + 1).charAt(0);

            if (operStack.isOper(ch)) {
                if (!operStack.isEmpty()) {
                    //说明符号栈中已经存在符号，需要根据两个符号的优先级进行处理
                    if (operStack.getPriority(ch) <= operStack.getPriority(operStack.peekTop())){
                        //说明当前符号的优先级小于栈中的优先级
                        num1 = numStack.pop();
                        num2 = numStack.pop();
                        oper = operStack.pop();
                        int temp = numStack.cal(num1, num2, oper);
                        //然后把运算的结果入数栈
                        numStack.push(temp);
                        operStack.push(ch);
                    } else {
                        operStack.push(ch);
                    }
                } else {
                    //说明符号栈为空，那么直接把当前符号入栈即可
                    operStack.push(ch);
                }
            } else {
                //说明不是符号，而是数字，直接入数栈即可
                //因为字符型的数字，比如说1，其实字符型的时候是49
                //这个会有一个问题：只能计算<10,也就是只有一位数的值的计算
                //numStack.push(ch - 48);//这种就只能
                keepNum+=ch;

                if (index == expStr.length()-1) {
                    //说明已经是最后一个数字了
                    numStack.push(Integer.parseInt(keepNum)) ;
                    break;
                } else {
                    //判断下一个字符是不是符号，不是符号，需要继续，只有是符号后，才能入栈
                    if (operStack.isOper(expStr.substring(index+1, index+2).charAt(0))) {
                        //是符号为，那么可以入栈了
                        numStack.push(Integer.parseInt(keepNum));
                        keepNum = "";
                    }
                    //如果不是，那么就紧接着继续循环即可
                }

            }

            index++;

            if (index >= expStr.length()) {
                //说明已经是最后一个数字了
                break;
            }
        }

        //当表达式扫描完毕，就顺序的从数栈和符号栈中pop出对应的数字和符号，进行运算即可
        while (true) {
            if (operStack.isEmpty()) {
                break;
            }

            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            int temp = numStack.cal(num1, num2, oper);
            numStack.push(temp);
        }

        System.out.println("结果是：" + numStack.pop());
    }
}


class CalcArrayStack {

    private int maxSize;
    private int[] stack;
    //入栈的时候position加1，出栈的时候position减1，这样子就可以模拟出先入的后出
    private int position = -1;

    public CalcArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }


    public int peekTop() {
        return stack[position];
    }

    //计算方法，num1是先被出栈的数字，num2是后出栈的顺序，计算减法和除法的时候需要留意顺序
    public int cal(int num1, int num2, int oper) {
        int result = 0;
        switch (oper) {
            case '+':
                result = num1+num2;
                break;
            case '-':
                result = num2-num1;
                break;
            case '*':
                result = num1*num2;
                break;
            case '/':
                result = num2/num1;
                break;
        }
        return result;
    }


    //判断字符是不是运算符
    public boolean isOper(int val) {
        return val == '+' || val == '-' || val == '*' || val == '/';
    }

    //优先级使用数字表示，数据越大，优先级越高.char类型可以和int类型相互转换的哈
    public int getPriority(int oper) {
        if (oper == '*' || oper == '/') {
            return 1;
        } else if (oper == '+' | oper == '-') {
            return 0;
        } else  {
            return -1;
        }
    }

    public boolean isFull() {
        return position == maxSize - 1;
    }

    public boolean isEmpty() {
        return position == -1;
    }

    public void push(int value) {
        if (isFull()) {
            System.out.println("full-----");
            return;
        }
        position++;
        stack[position] = value;
    }

    public int pop() {
        if (isEmpty()) {
            System.out.println("empty----");
            throw new RuntimeException("empty--");
        }

        int value = stack[position];
        position--;
        return value;
    }

    public void showStack() {
        if (isEmpty()) {
            System.out.println("empty");
            return;
        }
        for (int i = position; i >= 0; i--) {
            System.out.printf("stack[%d]=%d \n", i, stack[i]);
        }
    }
}
```



#### 1.1.5, 计算器实现的波兰表达式和逆波兰表达式

#####  前缀表达式(波兰表达式)

> 波兰表达式又称前缀表达式，就是运算符位于操作数之前
>
> 举例说明： (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6

```java
从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（栈顶元素 和 次顶元素），并将结果入栈；重复上述过程直到表达式最左端，最后运算得出的值即为表达式的结果

例如: (3+4)×5-6 对应的前缀表达式就是 - × + 3 4 5 6 , 针对前缀表达式求值步骤如下:

从右至左扫描，将6、5、4、3压入堆栈
遇到+运算符，因此弹出3和4（3为栈顶元素，4为次顶元素），计算出3+4的值，得7，再将7入栈
接下来是×运算符，因此弹出7和5，计算出7×5=35，将35入栈
最后是-运算符，计算出35-6的值，即29，由此得出最终结果
```





##### 中缀表达式(正常的计算表达式)

> 举例说明： (3+4)×5-6 就是中缀表达式



##### 后缀表达式(逆波兰表达式)

> 逆波兰表达式又称后缀表达式，与前缀表达式相似，只是运算符位于操作数之后
>
> 举例说明： (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 –
>
> | 中缀表达式 | 逆波兰表达式(后缀表达式) |
> | ---------- | ------------------------ |
> | a+b        | a b +                    |
> | a+(b-c)    | a b c - +                |
> | a+(b-c)*d  | a b c – d * +            |
> | a+d*(b-c)  | a d b c - * +            |
> | a=1+3      | a 1 3 + =                |

```java
后缀表达式的计算机求值

从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:

从左至右扫描，将3和4压入堆栈；
遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
将5入栈；
接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
将6入栈；
最后是-运算符，计算出35-6的值，即29，由此得出最终结果
```

```java
package im.bool.a04_stack;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Stack;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/16 11:10 PM
 * #Desc   : 逆波兰表达式计算器:给定一个逆波兰表达式，计算出结果
 *。         如何把常用的正常的计算式子转换成逆波兰表达式可以看后面的内容
 **/
public class a04_03_ReversePolandNotation {

    public static void main(String[] args) {

        //先定义逆波兰表达式
        //(3+4)*5-6
        //String expStr = "3 4 + 5 × 6 - ";


        //4*5-8+60+8/2  4 5 * 8 - 60 + 8 2 / +
        String expStr = "4 5 × 8 - 60 + 8 2 / +";

        int result = calc(getListString(expStr));
        System.out.println("结果是: " + result);

    }


    public static List<String> getListString(String reversePolandNotionStr) {
        //把逆波兰表达式根据空格切开，然后放入数组方便后续进行计算
        List<String> elements = new ArrayList<String>();
        String[] splitExp = reversePolandNotionStr.split(" ");
        Collections.addAll(elements, splitExp);
        return elements;
    }

    /*
 从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 和 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果

例如: (3+4)×5-6 对应的后缀表达式就是 3 4 + 5 × 6 - , 针对后缀表达式求值步骤如下:

从左至右扫描，将3和4压入堆栈；
遇到+运算符，因此弹出4和3（4为栈顶元素，3为次顶元素），计算出3+4的值，得7，再将7入栈；
将5入栈；
接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；
将6入栈；
最后是-运算符，计算出35-6的值，即29，由此得出最终结果
     */
    public static int calc(List<String> elemets) {
        //创建栈
        Stack<String> stack = new Stack<String>();

        for (String item : elemets) {
            //使用正则表达式取出数字
            if (item.matches("\\d+")) {
                stack.push(item);
            } else {
                //如果不是数字，那么就pop出两个数字，进行运算，然后重新入栈
                int num1 = Integer.parseInt(stack.pop());
                int num2 = Integer.parseInt(stack.pop());
                int result = 0;
                if (item.equals("+")) {
                    result = num1 + num2;
                } else if (item.equals("-")) {
                    result = num2 - num1;
                } else if (item.equals("×")) {
                    result = num1 * num2;
                } else if (item.equals("/")) {
                    result  = num2/num1;
                } else {
                    throw new RuntimeException("暂不支持的运算符号");
                }

                stack.push(result + "");
            }
        }

        //最终留在栈中的即是结果
        return Integer.parseInt(stack.pop());
    }
}
```



##### 中缀表达式转化为后缀表达式(逆波兰表达式)

* 这里感觉用处不大，知道了大致的内容，具体的代码就不写了。



#### 1.1.6, 迭代

##### 迭代的基本应用

```java
package im.bool.a05_recursive_stack;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/23 9:06 AM
 * #Desc   : 迭代算法的一些基本应用
 **/
public class a05_01_Recursive {

    public static void main(String[] args) {

        //打印递归
        //这里打印10 9 8 7 6 5 4 3 2 1从大到小
//        printRecursively(10);
        //这里打印1 2 3 4 5 6 7 8 9 10从小到大
//        printRecursively01(10);
        //这里只会打印0
//        printRecursively02(10);

        //阶乘问题
        int factorial = factorial(10);
        System.out.println(factorial);

    }

    public static int factorial(int n) {
        if (n == 1) {
            return 1;
        } else {
            return factorial(n-1)*n;
        }
    }

    public static void printRecursively02(int n) {
        if (n >= 1) {
            printRecursively02(n-1);
        } else {
            System.out.println(n);
        }
    }

    public static void printRecursively01(int n) {
        if (n >= 1) {
            printRecursively01(n-1);
        }

        System.out.println(n);
    }

    public static void printRecursively(int n) {
        if (n >= 1) {
            System.out.println(n);
            printRecursively(n-1);
        }
    }
}
```



##### 迷宫回溯问题

```java
package im.bool.a05_recursive_stack;

/**
 * #Author : ivanl001
 * #Date   : 2020/2/21 8:26 AM
 * #Desc   : 通过递归实现迷宫回溯问题
 **/
public class a05_02_Labyrinth {

    public static void main(String[] args) {

        //1, 模拟迷宫
        int[][] labyrinth = new int[8][7];

        //2, set column0 and column6 as wall
        for (int i = 0; i < 8; i++) {
            labyrinth[i][0] = 1;
            labyrinth[i][6] = 1;
        }

        //3, set row0 and row7 as wall
        for (int j = 0; j < 7; j++) {
           labyrinth[0][j] = 1;
           labyrinth[7][j] = 1;
        }

        //4, set special brick
        labyrinth[3][1] = 1;
        labyrinth[3][2] = 1;

        /*labyrinth[1][2] = 1;
        labyrinth[2][2] = 1;*/

        //5, 打印迷宫
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(labyrinth[i][j] + " ");
            }
            System.out.println();
        }

        //6, go through the labyrinth
        boolean finished = goThroughtLabyrinth(labyrinth, 1, 1);
        if (finished == true) {
            System.out.println("走出迷宫");
        } else {
            System.out.println("迷宫不同，是死的");
        }

        //7, see the map
        for (int i = 0; i < 8; i++) {
            for (int j = 0; j < 7; j++) {
                System.out.print(labyrinth[i][j] + " ");
            }
            System.out.println();
        }
    }

    /**
     * @param labyrinth
     * @param i the start row
     * @param j the start column
     */
    private static boolean goThroughtLabyrinth(int[][] labyrinth, int i, int j) {
        if (labyrinth[6][5] == 2) {
            //get out of the exist
            System.out.println("find the exit");
            return true;
        } else {
            if (labyrinth[i][j] == 0) {
                //mark the way
                labyrinth[i][j] = 2;
                // follow the rule to go through the labyrinth
                //first go down , if not ok, go right, if not ok, go up, then go left
                if (goThroughtLabyrinth(labyrinth, i + 1, j) == true) {
                    return true;
                } else if (goThroughtLabyrinth(labyrinth, i, j + 1) == true) {
                    return true;
                } else if (goThroughtLabyrinth(labyrinth, i - 1, j) == true) {
                    return true;
                } else if (goThroughtLabyrinth(labyrinth, i, j - 1) == true) {
                    return true;
                } else {
                    labyrinth[i][j] = 3;
                    return false;
                }
            } else {
                return false;
            }
        }
    }
}
```



### 1.2, 非线性结构

> 非线性结构包括：二维数组，多维数组，广义表，树结构，图结构



数组每次插入都需要复制当前数据到一个新的数据才能有类似扩容的功能。List其实是一种优化的数组，会尽量批量扩容，不会每次插入扩容，底层使用的还是数组。这种因素导致数组在插入的时候速度慢。

然后链表的话插入的时候速度就很快了，但是查找的时候，如果链表数据很多，就需要从头查找到尾部，其实相对而言查找速度就比较慢。

这就是学习树结构的原因。



![image-20200308100424445](asserts/image-20200308100424445.png)



![image-20200308100345885](asserts/image-20200308100345885.png)











#### 1.2.1, 二维数组

#### 1.2.2, 多维数组

#### 1.2.3, 广义表

#### 1.2.4, 数结构

#### 1.2.5, 图结构